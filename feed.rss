<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namecoin</title>
    <description><!--Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
--></description>
    <link>https://namecoin.org//</link>
    <atom:link href="https://namecoin.org//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 17 Apr 2018 08:25:28 +0000</pubDate>
    <lastBuildDate>Tue, 17 Apr 2018 08:25:28 +0000</lastBuildDate>
    <generator>Jekyll v3.6.0</generator>
    
      <item>
        <title>ncdns v0.0.6 Released</title>
        <description>&lt;p&gt;We’ve released ncdns v0.0.6.  List of changes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows installer:
    &lt;ul&gt;
      &lt;li&gt;Bump ConsensusJ-Namecoin dependency to v0.2.7.&lt;/li&gt;
      &lt;li&gt;Bump Dnssec-Trigger dependency to v0.15.  (Patch by Jeremy Rand.)&lt;/li&gt;
      &lt;li&gt;Bump dnssec-keygen dependency to v9.12.1.  (Patch by Jeremy Rand.)&lt;/li&gt;
      &lt;li&gt;Code quality improvements.  (Patch by Hugo Landau; reported by Jeremy Rand.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NetBSD:
    &lt;ul&gt;
      &lt;li&gt;Disable NetBSD/ARM builds due to an upstream bug.  NetBSD/ARM builds will return later.  (Patch by Jeremy Rand.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;All OS’s:
    &lt;ul&gt;
      &lt;li&gt;certinject: Add support for NSS trust stores; this enables positive TLS overrides in Chromium on GNU/Linux (and probably various other software that uses NSS for certificate validation.  (Patch by Jeremy Rand.)&lt;/li&gt;
      &lt;li&gt;ncdumpzone: Add &lt;code class=&quot;highlighter-rouge&quot;&gt;cert_override.txt&lt;/code&gt; output format; this enables positive TLS overrides in Firefox (and probably various other software based on Firefox).  (Patch by Jeremy Rand.)&lt;/li&gt;
      &lt;li&gt;Fix TLSA records served over DNS (for the lucky users using software that supports DANE).  (Patch by Jeremy Rand; reported by Jefferson Carpenter.)&lt;/li&gt;
      &lt;li&gt;Bundle miekg’s &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;.  (Patch by Jeremy Rand.)&lt;/li&gt;
      &lt;li&gt;Bundle &lt;code class=&quot;highlighter-rouge&quot;&gt;dns-prop279&lt;/code&gt;.  (Patch by Jeremy Rand.)&lt;/li&gt;
      &lt;li&gt;Change default Namecoin RPC host from &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;; should fix some RPC errors on Windows.  (Patch by Jeremy Rand.)&lt;/li&gt;
      &lt;li&gt;Code quality improvements.  (Patch by Jeremy Rand.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/#ncdns&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Apr 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/04/17/ncdns-v0.0.6-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/04/17/ncdns-v0.0.6-released.html</guid>
        
        <category>Releases</category>
        
        <category>ncdns Releases</category>
        
        
      </item>
    
      <item>
        <title>ConsensusJ-Namecoin v0.2.7 Binaries Available</title>
        <description>&lt;p&gt;Binaries of ConsensusJ-Namecoin (the Namecoin lightweight SPV lookup client) v0.2.7 are now released on the &lt;a href=&quot;/download/betas/#consensusj-namecoin&quot;&gt;Beta Downloads page&lt;/a&gt; page.  This is based on the source code that was &lt;a href=&quot;/2017/11/30/spv-lookup-0.2.7-beta-1.html&quot;&gt;released earlier&lt;/a&gt;.  Notable new things in this release:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;leveldbtxcache&lt;/code&gt; mode is merged to upstream libdohj, and has therefore had the benefit of more peer review.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;leveldbtxcache&lt;/code&gt; mode now only stores the name scriptPubKey, not the entire transaction.  This significantly improves syncup time and storage usage.  (Currently, it uses around 65 MB of storage, which includes both the name database and the block headers.)&lt;/li&gt;
  &lt;li&gt;Many dependency version bumps.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;As usual, ConsensusJ-Namecoin is experimental.  Namecoin Core is still substantially more secure against most threat models.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Apr 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/04/03/consensusj-0.2.7-binaries.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/04/03/consensusj-0.2.7-binaries.html</guid>
        
        <category>Releases</category>
        
        <category>libdohj Releases</category>
        
        
      </item>
    
      <item>
        <title>Integrating Cross-Signing with Name Constraints into NSS</title>
        <description>&lt;p&gt;At the end of &lt;a href=&quot;/2018/03/25/cross-signing-name-constraints-go.html&quot;&gt;my previous post about porting cross-signing with name constraints to Go&lt;/a&gt;, I mentioned that the next phase was to automate the procedure of applying the constraints to all root CA’s in NSS, instead of needing to manually dump CA’s one-by-one from NSS, run them through my Go tool (currently named &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt;, because I’ve exhausted my witty software naming quota on another project&lt;a href=&quot;#footnote1&quot;&gt;[1]&lt;/a&gt;), and import them back into NSS.  I’m happy to report that this next phase is essentially complete, and in my testing I blacklisted certificates for the &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; TLD regardless of which built-in root CA they chained to (without any impact on other TLD’s).&lt;/p&gt;

&lt;p&gt;My previous post went into quite a bit of technical detail (more so than a typical post of mine), mainly because the details of getting Go to cross-sign with name constraints with minimal attack surface were actually rather illuminating.  In contrast, most of the technical details I could provide for this phase are rather boring (in my opinion, at least), so this post will be more high-level and somewhat shorter than the previous post.  (And no code snippets this time!)&lt;/p&gt;

&lt;p&gt;Early on, I had to make a design decision about how to interact with NSS.  There were 3 main options available:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pipe data through &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Link with the NSS shared libraries via cgo.&lt;/li&gt;
  &lt;li&gt;Do something weird with sqlite.  (This category actually includes a wide variety of strange things, including using sqlite’s command line utility, using sqlite with cgo, and using horrifying &lt;code class=&quot;highlighter-rouge&quot;&gt;LD_PRELOAD&lt;/code&gt; hooks to intercept NSS’s interaction with sqlite.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given that I haven’t used sqlite in several years, and that I’ve never actually used cgo, but I use &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; on a daily (if not hourly) basis these days, it was pretty clear that option 1 was going to be the most effective usage of my development time.  And it actually came together surprisingly fast, into a command-line tool that I call &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; (note the naming similarity to &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_chromium_tool&lt;/code&gt; – the functionality is analogous).  A few of the more “interesting” things I ended up dealing with:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Using &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; to retrieve a list of all certificate nicknames in a database looks like it returns an error.  I say “looks like” because there’s actually no error.  The standard output contains all the data I asked for, and the standard error is empty.  But for some reason &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; returns exit code 1 (indicating an error), not exit code 0 (indicating success), for this particular operation.  The exit codes for other operations in &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; don’t exhibit this issue.  I ended up just having my code treat exit code 1 as exit code 0 for this particular operation, which seems to work okay.&lt;/li&gt;
  &lt;li&gt;When an NSS database contains 2 different certificates that contain the same Subject and Public Key, NSS actually can’t keep track of which is which.  The metadata stays consistent, but when you ask for the DER-encoded certificate data for 1 of the certificates, NSS decides to give you &lt;strong&gt;both of them&lt;/strong&gt;.  Concatenated together.  This led to me writing some generally horrifying code that tries to check for the presence of a certificate by doing both a prefix and suffix match against a byte slice (since I don’t have any idea what order the certificates will be concatenated in).  It’s probably somewhat safer to change &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; to use PEM encoding rather than DER, since it’s easier to detect boundaries of concatenated PEM blocks.  I’ll probably do this next time I’m cleaning up the code.&lt;/li&gt;
  &lt;li&gt;I accidentally applied a name constraint excluding &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; the first time it ran successfully, and while trying to undo my mistake, I realized I hadn’t ever considered &lt;strong&gt;how to uninstall&lt;/strong&gt; all of these extra certificates.  Back when I was just dealing with a single CA, it was easy to uninstall them via &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; by hand, but at this scale it’s not feasible to do that.  So I ended up adding an extra uninstall mode.  It turned out to be relatively straightforward – apparently my design was flexible enough that this functionality wasn’t hard to add, even though I had never explicitly thought about how I would do it.  &lt;em&gt;Whew!&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;The big one.  Applying the name constraint to the entire NSS built-in certificate list (starting with a mostly-stock database) took &lt;strong&gt;6 minutes and 48 seconds&lt;/strong&gt;.  I strongly suspect that most of this overhead is because NSS doesn’t support sqlite batching, so for every certificate that gets cross-signed, something like 7 sqlite transactions are issued.  On the bright side, my code is smart enough to not attempt to cross-sign certificates for which an existing cross-signature is already present, so the 2nd time you run it, it only takes 20 seconds (which is mostly spent dumping the existing certificates in order to verify that no changes are needed).  Of course, if the trust bits get changed in the built-in list (or if the DER encoded value of a built-in certificate changes), the old cross-signature will be removed, and a new cross-signature will be added.  (Technically there are probably some interesting race conditions here, and properly fixing that is on my to-do list.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Anyway, once the 6 minutes and 48 seconds to run &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; had elapsed, I launched Firefox (this was being done with a Firefox NSS sqlite database on Fedora), and was pleased to see as soon as Firefox booted, I immediately got a certificate error – Firefox’s home page was set to &lt;a href=&quot;https://start.fedoraproject.org/&quot;&gt;https://start.fedoraproject.org/&lt;/a&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; was the excluded domain in the name constraint that I configured for the test.  I tested various &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; websites with a variety of root CA’s, and the result was consistent: all &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; sites showed a certificate error, while &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; websites worked fine.  For example, when I looked at the certificate chain for &lt;a href=&quot;https://www.startpage.com/&quot;&gt;StartPage&lt;/a&gt;, Firefox reported that the trust anchor was named &lt;code class=&quot;highlighter-rouge&quot;&gt;Namecoin Restricted CKBI Root CA for COMODO RSA Certification Authority&lt;/code&gt;, indicating that the name constraints had indeed taken effect.&lt;/p&gt;

&lt;p&gt;I think the code is now at the point where I’ll soon be pushing it to GitHub, and maybe doing some binary releases for people who want to &lt;del&gt;brick their NSS database and lose their client certificate private keys&lt;/del&gt; try it out in a VM and report how it works.  All that said, a few interesting caveats remain:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; only applies name constraints to certificates from Mozilla’s CKBI (built-in certificates) module.  If you’re in the business of manually importing extra root CA’s, I’m currently assuming that one of the following is true:
    &lt;ul&gt;
      &lt;li&gt;You’re deliberately intercepting your traffic for debug purposes, and therefore don’t want the name constraint to apply.&lt;/li&gt;
      &lt;li&gt;You’re capable of using &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; to manually add the name constraint before you import a root CA.&lt;/li&gt;
      &lt;li&gt;You’ve read this warning and ignored it, and therefore when you get pwned by Iranian intelligence agencies, I’m not responsible.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; has the side effect of making trust anchors from the CKBI module no longer appear to be from the CKBI module.  Why does this matter?  Many key pinning implementations only enforce key pins against CKBI trust anchors.  (This is actually the trick we were &lt;del&gt;abusing&lt;/del&gt; innovatively utilizing with &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_chromium_tool&lt;/code&gt;, but now it’s working against us rather than in our favor.)  Mitigating factors:
    &lt;ul&gt;
      &lt;li&gt;Chromium-based browsers are &lt;a href=&quot;https://groups.google.com/a/chromium.org/d/topic/blink-dev/he9tr7p3rZ8&quot;&gt;scrapping HPKP soon&lt;/a&gt;, so if your security model is dependent on HPKP working in Chromium, you might want to re-evaluate soon.&lt;/li&gt;
      &lt;li&gt;Chromium’s HPKP was &lt;em&gt;already&lt;/em&gt; completely broken on Fedora &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=707280&quot;&gt;due to a Chromium bug&lt;/a&gt;.  It turns out that p11-kit, which Fedora uses as a drop-in replacement for CKBI, utilizes an NSS feature to indicate that it should be treated as CKBI, but Chromium didn’t use that NSS feature properly, and the Chromium devs had minimal interest in fixing it.  Chromium’s devs explained this decision by saying that HPKP is a best-effort feature, and that HPKP failure is not considered a security issue in Chromium.  (The bug was eventually fixed on December 28, 2017, approximately 9 months after it was reported to Chromium.)  So again, if your security model is dependent on HPKP working in Chromium, you might want to re-evaluate, because the Chromium devs don’t agree with you.&lt;/li&gt;
      &lt;li&gt;Firefox’s HPKP can be &lt;a href=&quot;https://wiki.mozilla.org/SecurityEngineering/Public_Key_Pinning#How_to_use_pinning&quot;&gt;optionally configured via &lt;code class=&quot;highlighter-rouge&quot;&gt;about:config&lt;/code&gt;&lt;/a&gt; to enforce even for non-CKBI trust anchors.  If you’re not deliberately intercepting your own traffic, you probably should enable this mode.&lt;/li&gt;
      &lt;li&gt;It’s arguably an NSS certutil bug that the CKBI-emulating flag that p11-kit uses can’t be read/set by certutil.  Mozilla should probably fix that sometime.&lt;/li&gt;
      &lt;li&gt;Once I port &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_p11_tool&lt;/code&gt; or something like that (i.e. port from NSS to p11-kit), it should be straightforward to mimic CKBI on Fedora, in the same way that p11-kit’s default CA’s mimic CKBI.  This should at least be recognized by Firefox (but not by Chromium, see above).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Using &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; requires that you have a &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; binary.  This is easily obtainable in most GNU/Linux distributions (in Fedora, it’s the &lt;code class=&quot;highlighter-rouge&quot;&gt;nss-tools&lt;/code&gt; package), but I have no idea how easy it is to get a &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; binary on Windows and macOS.  (No, the &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; program that Windows includes as part of CryptoAPI is not the same thing.)  Mozilla doesn’t distribute &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; binaries.  At some point, we’ll probably need to start cross-compiling NSS ourselves, although I admit I’m not sure I’m going to enjoy that.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; only works for NSS applications that actually use a certificate database.  Notably, Tor Browser doesn’t use a certificate database, because such a feature forms a fingerprinting risk.  (To my knowledge, Tor Browser exclusively uses the NSS CKBI module.)  Long term, we could probably &lt;del&gt;add a bunch of attack surface&lt;/del&gt; work around this issue by replacing Tor Browser’s CKBI module with p11-kit’s drop-in replacement.  p11-kit is read-only, so in theory it can’t be used as a cookie like NSS’s certificate database can.  But if you customize your CKBI module’s behavior in any significant way, you’re definitely altering your browser fingerprint.  Assuming that all Namecoin users of Tor Browser do this the same way, it’s not really a problem, since the ability to access &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains will already alter your browser fingerprint, and replacing CKBI with p11-kit shouldn’t cause any extra anonymity set partitioning beyond that.  But it’s definitely not something that should be done lightly.&lt;/li&gt;
  &lt;li&gt;Right now, &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; only supports sqlite databases in NSS.  The older BerkeleyDB databases might be possible to support in the future, but since everything is moving toward sqlite anyway, adding BerkeleyDB support is not exactly high on my priority list.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Despite these minor caveats, this is an excellent step forward for Namecoin TLS on a variety of applications and OS’s.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;

&lt;div id=&quot;footnote1&quot;&gt;

  &lt;p&gt;[1] I &lt;em&gt;might&lt;/em&gt; have written a program late last year for my master’s thesis, given it a name that is simultaneously (1) an obscure Harry Potter joke, (2) an anonymity technology joke, and (3) a Latin and Greek joke, and then devoted about 2-3 pages of my master’s thesis to explaining and elaborating on the compound joke.  I probably didn’t do that though; that might constitute trolling my university, and I &lt;em&gt;certainly&lt;/em&gt; wouldn’t do that, would I?&lt;/p&gt;

&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Mar 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/03/26/integrating-cross-signing-name-constraints-nss.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/03/26/integrating-cross-signing-name-constraints-nss.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Cross-Signing with Name Constraints Ported to Go</title>
        <description>&lt;p&gt;In &lt;a href=&quot;/2018/03/11/p11-kit-negative-overrides.html&quot;&gt;my previous post about achieving negative certificate overrides using cross-signing and name constraints&lt;/a&gt;, I discussed how the technique could make Namecoin-authenticated TLS possible in any TLS application that uses p11-kit or NSS for its certificate storage.  However, the proof-of-concept implementation I discussed in that post was definitely not a secure implementation (nor was the code sane to look at), due to the usage of OpenSSL’s command line utility (glued to itself with Bash) for performing the cross-signing.  I’m happy to report that I’ve ported the OpenSSL+Bash-based code to Go.&lt;/p&gt;

&lt;p&gt;Creating a self-signed root CA in Go is relatively easy (&lt;a href=&quot;https://golang.org/src/crypto/tls/generate_cert.go&quot;&gt;there’s example code for it in the Go standard library&lt;/a&gt;, which happens to be the code on which Namecoin’s &lt;code class=&quot;highlighter-rouge&quot;&gt;generate_nmc_cert&lt;/code&gt; tool is heavily based).  Signing an existing certificate with that root CA is also pretty straightforward.  The standard library’s &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package in Go 1.9 and higher supports creating a CA with the name constraint features we want (earlier versions of Go’s &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package only supported a whitelist of domain names; we want a blacklist, which is newly added in 1.9).  Right now, ncdns is built with Go 1.8.3 due to a planned effort to use The Tor Project’s reproducible build scripts (which currently use Go 1.8.3), but this code will be used in a standalone tool that doesn’t need to be compiled into ncdns, so using Go 1.9 or higher isn’t a problem.  (That said, ncdns does have pending PR’s for upgrading to Go 1.9 and Go 1.10, which will be merged when The Tor Project updates their build scripts accordingly.)&lt;/p&gt;

&lt;p&gt;The tricky part here is that Go’s standard library’s &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package does &lt;strong&gt;a lot&lt;/strong&gt; of parsing and converting of the data in certificates, and a large amount of parsing/conversion of the CA certificate that we’re cross-signing introduces an increased risk of something in the certificate being altered in a way that affects certificate validation.  This could result in unwanted errors showing up for websites (including non-Namecoin websites), which would be bad enough, but it could also result in certificates being incorrectly &lt;strong&gt;accepted&lt;/strong&gt; – which would mean, among other horrible things, that MITM attacks could be performed, including against non-Namecoin websites.&lt;/p&gt;

&lt;p&gt;As one example of bad things that can happen if too much parsing is done, OpenSSL’s command-line tool doesn’t include x509v3 extensions by default when cross-signing.  x509v3 extensions are responsible for lots of things, including Basic Constraints (removing this would allow a CA to issue certs via intermediates that might not be valid), Name Constraints (we certainly don’t want to remove all the existing name constraints when we add a&lt;code class=&quot;highlighter-rouge&quot;&gt; .bit&lt;/code&gt;-excluding name constraint), and Key Usage and Extended Key Usage (which would make the CA valid for purposes that browsers aren’t supposed to trust it for, e.g. making the CA valid for signing executable code instead of just signing TLS certificates).  While I suspect that Go is at least mildly more sane than OpenSSL’s default settings, what I really wanted was a way to simply pass-through as much of the original root CA’s certificate as possible when cross-signing it.&lt;/p&gt;

&lt;p&gt;Here’s the Go struct that’s returned when an x509 certificate’s raw DER form is passed to the &lt;code class=&quot;highlighter-rouge&quot;&gt;ParseCertificate&lt;/code&gt; function in the standard library’s &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// A Certificate represents an X.509 certificate.
type Certificate struct {
	Raw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).
	RawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.
	RawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.
	RawSubject              []byte // DER encoded Subject
	RawIssuer               []byte // DER encoded Issuer

	Signature          []byte
	SignatureAlgorithm SignatureAlgorithm

	PublicKeyAlgorithm PublicKeyAlgorithm
	PublicKey          interface{}

	Version             int
	SerialNumber        *big.Int
	Issuer              pkix.Name
	Subject             pkix.Name
	NotBefore, NotAfter time.Time // Validity bounds.
	KeyUsage            KeyUsage

	// Extensions contains raw X.509 extensions. When parsing certificates,
	// this can be used to extract non-critical extensions that are not
	// parsed by this package. When marshaling certificates, the Extensions
	// field is ignored, see ExtraExtensions.
	Extensions []pkix.Extension

	// ExtraExtensions contains extensions to be copied, raw, into any
	// marshaled certificates. Values override any extensions that would
	// otherwise be produced based on the other fields. The ExtraExtensions
	// field is not populated when parsing certificates, see Extensions.
	ExtraExtensions []pkix.Extension

	// UnhandledCriticalExtensions contains a list of extension IDs that
	// were not (fully) processed when parsing. Verify will fail if this
	// slice is non-empty, unless verification is delegated to an OS
	// library which understands all the critical extensions.
	//
	// Users can access these extensions using Extensions and can remove
	// elements from this slice if they believe that they have been
	// handled.
	UnhandledCriticalExtensions []asn1.ObjectIdentifier

	ExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.
	UnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.

	// BasicConstraintsValid indicates whether IsCA, MaxPathLen,
	// and MaxPathLenZero are valid.
	BasicConstraintsValid bool
	IsCA                  bool

	// MaxPathLen and MaxPathLenZero indicate the presence and
	// value of the BasicConstraints' &quot;pathLenConstraint&quot;.
	//
	// When parsing a certificate, a positive non-zero MaxPathLen
	// means that the field was specified, -1 means it was unset,
	// and MaxPathLenZero being true mean that the field was
	// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false
	// should be treated equivalent to -1 (unset).
	//
	// When generating a certificate, an unset pathLenConstraint
	// can be requested with either MaxPathLen == -1 or using the
	// zero value for both MaxPathLen and MaxPathLenZero.
	MaxPathLen int
	// MaxPathLenZero indicates that BasicConstraintsValid==true
	// and MaxPathLen==0 should be interpreted as an actual
	// maximum path length of zero. Otherwise, that combination is
	// interpreted as MaxPathLen not being set.
	MaxPathLenZero bool

	SubjectKeyId   []byte
	AuthorityKeyId []byte

	// RFC 5280, 4.2.2.1 (Authority Information Access)
	OCSPServer            []string
	IssuingCertificateURL []string

	// Subject Alternate Name values
	DNSNames       []string
	EmailAddresses []string
	IPAddresses    []net.IP
	URIs           []*url.URL

	// Name constraints
	PermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.
	PermittedDNSDomains         []string
	ExcludedDNSDomains          []string
	PermittedIPRanges           []*net.IPNet
	ExcludedIPRanges            []*net.IPNet
	PermittedEmailAddresses     []string
	ExcludedEmailAddresses      []string
	PermittedURIDomains         []string
	ExcludedURIDomains          []string

	// CRL Distribution Points
	CRLDistributionPoints []string

	PolicyIdentifiers []asn1.ObjectIdentifier
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Holy crap, that’s a lot of parsing that’s clearly happening.  Among other things, we can even see special types being used for date/time values, IP addresses, and URL’s.  I definitely don’t want all that stuff being added to the attack surface of my cross-signing code – it seems almost certain that some mutation would end up happening, and it would be insane to try to audit the safety of whatever mutation occurs.&lt;/p&gt;

&lt;p&gt;However, under the hood, after the above monstrosity is serialized and is ready to be signed, a far more manageable set of structs is used by the &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package for the actual signing procedure:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// These structures reflect the ASN.1 structure of X.509 certificates.:

type certificate struct {
	Raw                asn1.RawContent
	TBSCertificate     tbsCertificate
	SignatureAlgorithm pkix.AlgorithmIdentifier
	SignatureValue     asn1.BitString
}

type tbsCertificate struct {
	Raw                asn1.RawContent
	Version            int `asn1:&quot;optional,explicit,default:0,tag:0&quot;`
	SerialNumber       *big.Int
	SignatureAlgorithm pkix.AlgorithmIdentifier
	Issuer             asn1.RawValue
	Validity           validity
	Subject            asn1.RawValue
	PublicKey          publicKeyInfo
	UniqueId           asn1.BitString   `asn1:&quot;optional,tag:1&quot;`
	SubjectUniqueId    asn1.BitString   `asn1:&quot;optional,tag:2&quot;`
	Extensions         []pkix.Extension `asn1:&quot;optional,explicit,tag:3&quot;`
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Readers unfamiliar with Go programming should note that in Go, structs whose name has an uppercase first letter are public (accessible by code outside the Go standard library’s &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package), while structs whose name has a lowercase first letter are private (only accessible from the Go standard library’s &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package).  These more manageable structs are private, so we can’t access them directly.  But, the important thing to note is that when a raw DER-encoded byte array is parsed into a crazy-complicated &lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;, as well as when a crazy-complicated &lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; is signed (resulting in a raw DER-encoded byte array), these private structs (&lt;code class=&quot;highlighter-rouge&quot;&gt;certificate&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tbsCertificate&lt;/code&gt;) are used as intermediate steps, and are actually processed by the &lt;code class=&quot;highlighter-rouge&quot;&gt;asn1&lt;/code&gt; package (not the &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package) when converting to and from raw DER-encoded byte arrays.&lt;/p&gt;

&lt;p&gt;The first field (&lt;code class=&quot;highlighter-rouge&quot;&gt;Raw&lt;/code&gt;) of each struct simply holds the unparsed binary ASN.1 representation of that struct, and we can generally ignore it.  I suspect that the &lt;code class=&quot;highlighter-rouge&quot;&gt;tbs&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;tbsCertificate&lt;/code&gt; stands for “to be signed”, since it contains all of the certificate data that the signature covers (in other words, everything except the signature).  The only 5 fields that we actually will want to replace when cross-signing are the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;certificate&lt;/code&gt;:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SignatureAlgorithm&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SignatureValue&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;tbsCertificate&lt;/code&gt;:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SerialNumber&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SignatureAlgorithm&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Issuer&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When a field is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;asn1.RawValue&lt;/code&gt;, it means that Go won’t try to parse its content in any way (it’s just a binary blob).  This is exactly the behavior we want for all the fields that we pass-through.  Unfortunately, &lt;code class=&quot;highlighter-rouge&quot;&gt;tbsCertificate&lt;/code&gt; has a bunch of other fields besides the above 5 replaced fields that aren’t of the type &lt;code class=&quot;highlighter-rouge&quot;&gt;asn1.RawValue&lt;/code&gt;.  What can we do about that?  Well, since these are private structs to the &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package, we’re clearly going to have to copy their definitions anyway – so how about we simplify them while we’re at it?  Below are my modified structs:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// These are modified from the x509 package; they store any field that isn't
// replaced by cross-signing as an asn1.RawValue.

type certificate struct {
	Raw                asn1.RawContent
	TBSCertificate     tbsCertificate
	SignatureAlgorithm asn1.RawValue
	SignatureValue     asn1.BitString
}

type tbsCertificate struct {
	Raw                asn1.RawContent
	Version            asn1.RawValue   `asn1:&quot;optional,explicit,tag:0&quot;`
	SerialNumber       *big.Int        // Replaced by cross-signing
	SignatureAlgorithm asn1.RawValue   // Replaced by cross-signing
	Issuer             asn1.RawValue   // Replaced by cross-signing
	Validity           asn1.RawValue
	Subject            asn1.RawValue
	PublicKey          asn1.RawValue
	UniqueId           asn1.RawValue   `asn1:&quot;optional,tag:1&quot;`
	SubjectUniqueId    asn1.RawValue   `asn1:&quot;optional,tag:2&quot;`
	Extensions         []asn1.RawValue `asn1:&quot;optional,explicit,tag:3&quot;`
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From there, I created a modified version of the &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package’s signing code, which creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;tbsCertificate&lt;/code&gt; by parsing the original CA certificate that we’re cross-signing (instead of populating it with serialized data from the crazy-complicated &lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; struct as the &lt;code class=&quot;highlighter-rouge&quot;&gt;x509&lt;/code&gt; package does), and then signs it (via ECDSA) and serializes it (via the &lt;code class=&quot;highlighter-rouge&quot;&gt;asn1&lt;/code&gt; package) as usual.  It then outputs a DER-encoded x509 certificate that’s identical to the original root CA cert, except for the 5 fields that I listed above as relevant to cross-signing.&lt;/p&gt;

&lt;p&gt;The end result of all this work is a Go library, and associated Go command-line tool, that accepts the following as input:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Original DER-encoded x509 certificate of a root CA to cross-sign&lt;/li&gt;
  &lt;li&gt;A domain name to blacklist via a name constraint (defaults to &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Subject CommonName prefixes for the root and intermediate CA’s (defaults to “Namecoin Restricted CKBI Root CA for “ and “Namecoin Restricted CKBI Intermediate CA for “), which are prepended to the cross-signed CA’s Subject CommonName when creating the root and intermediate CA’s (the intention here is to make it easy to recognize these CA’s as special based on their names)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;… and outputs the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DER-encoded x509 certificate of a new self-signed root CA (whose private key is destroyed)&lt;/li&gt;
  &lt;li&gt;DER-encoded x509 certificate of a new intermediate CA (whose private key is destroyed) that has a name constraint, signed by the new root CA&lt;/li&gt;
  &lt;li&gt;DER-encoded x509 certificate of the input root CA, cross-signed by the new intermediate CA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The root and intermediate CA’s also have a Subject SerialNumber that contains the following message:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“This certificate was created on this machine to apply a name constraint to an existing root CA.  Its private key was deleted immediately after the existing root CA was cross-signed.  For more information, see [TODO]”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(Of course, the Subject SerialNumber of the intermediate CA is also visible as the Issuer SerialNumber of the cross-signed CA.)  The intention here is that if someone encounters one of these certificates, they’ll notice the SerialNumber message and therefore they won’t mistakenly assume that their system has been compromised by a malicious CA certificate.  (The “[TODO]” will be replaced later by a URL that contains additional information and explains how to get the source code.)  Kudos to Ryan Castellucci for tipping me off that the Subject SerialNumber field was well-suited to this trick.&lt;/p&gt;

&lt;p&gt;With this Go command-line tool, I applied a name constraint blacklisting &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; to the certificate of &lt;code class=&quot;highlighter-rouge&quot;&gt;DST Root CA X3&lt;/code&gt; (as in my previous post, this is the root CA that Let’s Encrypt uses), and I got 3 new certificates as output.  I added those 3 certs to NSS’s sqlite database via &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; (marking the new root CA as trusted), marked the old root CA as untrusted, and tried visiting the same 2 sites that use Let’s Encrypt that I used in my previous post (&lt;a href=&quot;https://tehnoetic.com/&quot;&gt;Technoethical&lt;/a&gt; and &lt;a href=&quot;https://www.namecoin.org/&quot;&gt;Namecoin.org&lt;/a&gt;).  And happily, it worked just as my old OpenSSL+Bash version did: Technoethical loaded without errors (since it’s in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; TLD, which I didn’t blacklist), but Namecoin.org showed a TLS certificate error (since it’s in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; TLD that I chose to blacklist).&lt;/p&gt;

&lt;p&gt;This worked in both Chromium and Firefox on GNU/Linux.  And inspecting the resulting cross-signed certificate shows that all of the x509v3 extensions, validity period, etc. from the original &lt;code class=&quot;highlighter-rouge&quot;&gt;DST Root CA X3&lt;/code&gt; are passed through intact.  Yay!&lt;/p&gt;

&lt;p&gt;So, what’s next?  Right now, this still takes a single root CA as input (and the user is still responsible for passing in the input root CA, and making the needed changes to NSS’s database using the outputted CA’s).  I’ve started work on a Go program that will automate this procedure for all root CA’s in NSS; I’d say it’s somewhere around 50% complete.  Once it’s complete, this should allow us to continue supporting Chromium on GNU/Linux (even after Chromium removes HPKP), and it should also allow us to add support for Firefox on all OS’s (without requiring any WebExtensions support).&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/03/25/cross-signing-name-constraints-go.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/03/25/cross-signing-name-constraints-go.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin at 34C3: Slides and Videos</title>
        <description>&lt;p&gt;CCC and Chaos West have posted the videos of Namecoin’s 34C3 talks.  I’ve also uploaded the corresponding slides.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Namecoin as a Decentralized Alternative to Certificate Authorities for TLS&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://media.ccc.de/v/34c3-ChaosWest-3-namecoin_as_a_decentralized_alternative_to_certificate_authorities_for_tls&quot;&gt;Video recording&lt;/a&gt; by Chaos West, hosted by CCC.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/resources/presentations/34C3/Namecoin_TLS_34C3_Monero_Assembly.pdf&quot;&gt;Slides&lt;/a&gt; hosted by Namecoin.org.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Namecoin for Tor Onion Service Naming (And Other Darknets)&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;(No video recording available.)&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/resources/presentations/34C3/Namecoin_Tor_34C3_Monero_Assembly.pdf&quot;&gt;Slides&lt;/a&gt; hosted by Namecoin.org.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;A Blueprint for Making Namecoin Anonymous&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://media.ccc.de/v/34c3-ChaosWest-11-a_blueprint_for_making_namecoin_anonymous&quot;&gt;Video recording&lt;/a&gt; by Chaos West, hosted by CCC.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/resources/presentations/34C3/Namecoin_Anonymity_34C3_Monero_Assembly.pdf&quot;&gt;Slides&lt;/a&gt; hosted by Namecoin.org.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Again, a huge thank you to the following groups who facilitated our participation at 34C3:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://events.ccc.de/congress/2017/wiki/index.php/Assembly:Monero_Assembly&quot;&gt;The Monero Assembly&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://events.ccc.de/congress/2017/wiki/index.php/Assembly:Chaos_West&quot;&gt;The Chaos West Assembly&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tehnoetic.com/&quot;&gt;Technoethical&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’re looking forward to 35C3!&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/03/19/34c3-slides-videos.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/03/19/34c3-slides-videos.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Negative Certificate Overrides for p11-kit</title>
        <description>&lt;p&gt;Fedora stores its TLS certificates via a highly interesting software package called &lt;a href=&quot;https://p11-glue.github.io/p11-glue/trust-module.html&quot;&gt;p11-kit&lt;/a&gt;.  p11-kit is designed to act as “glue” between various TLS libraries, so that (for example) Firefox, Chromium, and OpenSSL all see the same trust anchors.  p11-kit is useful from Namecoin’s perspective, since it means that if we can implement Namecoin support for p11-kit, we get support for all the trust stores that p11-kit supports for free.  I’ve just implemented a proof-of-concept of negative Namecoin overrides for p11-kit.&lt;/p&gt;

&lt;p&gt;As you may recall, the way our Chromium negative overrides currently work is by &lt;del&gt;abusing&lt;/del&gt; utilizing HPKP such that public CA’s can’t sign certificates for the &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; TLD.  p11-kit doesn’t support key pinning (it’s on their roadmap though!), but there is another fun mechanism we can use to achieve a similar result: name constraints.  Name constraints are a feature of the x509 certificate specification that allows a CA certificate to specify constraints on what domain names it can issue certificates for.  There are a few standard use cases for name constraints:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A large organization who wants to create a lot of certificates might buy a name-constrained CA certificate from a public CA, and then use that name-constrained CA to issue more certificates for their organization.  This reduces the overhead of asking a public CA to issue a lot of certificates on-demand, and doesn’t introduce any security issues because the name constraint prevents the organization from issuing certificates for domain names that they don’t control.&lt;/li&gt;
  &lt;li&gt;A corporate intranet might create a name-constrained root CA that’s only valid for domain names that are internal to the corporate intranet.  This way, employees can install the name-constrained root CA in order to access internal websites, and they don’t have to worry that the IT department might be MITM’ing their connections to the public Internet.&lt;/li&gt;
  &lt;li&gt;A public CA might have a name constraint in their CA certificate that disallows them from issuing certificates for TLD’s that have unique regulatory requirements.  For exampe, the Let’s Encrypt CA &lt;a href=&quot;https://community.letsencrypt.org/t/why-is-there-a-certificate-name-constraint-for-mil/10130&quot;&gt;has (or at one point had) a name constraint disallowing &lt;code class=&quot;highlighter-rouge&quot;&gt;.mil&lt;/code&gt;&lt;/a&gt;, presumably because the U.S. military has their own procedures for issuing certificates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The 1st use case is rarely ever used; I suspect that this is because it poses a risk to commercial CA’s’ business model.  The 2nd use case is also rarely ever used; I suspect this is because many corporate IT departments &lt;em&gt;want to&lt;/em&gt; MITM all their employees’ traffic, and most employees don’t have much negotiating power on this topic.  But the 3rd case is quite interesting… if Let’s Encrypt uses a name constraint blacklisting &lt;code class=&quot;highlighter-rouge&quot;&gt;.mil&lt;/code&gt;, could this be used for &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Unfortunately, we obviously can’t expect all of the public CA’s to have any interest in opting into a name constraint disallowing &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; in the way that Let’s Encrypt opted into disallowing &lt;code class=&quot;highlighter-rouge&quot;&gt;.mil&lt;/code&gt;.  However, there is a fun trick that can solve this: cross-signed certificates.  It turns out that it is possible to transform a public root CA certificate into an intermediate CA certificate, and sign that intermediate CA certificate with a root CA that we can create locally (this is called &lt;em&gt;cross-signing&lt;/em&gt;).  We can then remove the original root CA from the cert store, add our local root CA and the cross-signed CA to the cert store, and everything will work just like it did before.  This is helpful because any name constraints that a CA certificate contains will apply to any CA certificate that it cross-signs.&lt;/p&gt;

&lt;p&gt;Technically, &lt;a href=&quot;https://tools.ietf.org/html/rfc5280#section-4.2.1.10&quot;&gt;the RFC 5280 specification says&lt;/a&gt; that root CA’s can’t have name constraints.  That’s not really a problem though: it just means that we have to create a local intermediate CA (signed by the local root CA) that has the name constraint, and cross-sign the public CA with the name-constrained local intermediate CA.  So the cert chain looks like this:&lt;/p&gt;

&lt;p&gt;Local root CA (no name constraint) –&amp;gt; Local intermediate CA (name constraint blacklisting .bit) –&amp;gt; Cross-signed public CA –&amp;gt; (everything past here is unaffected).&lt;/p&gt;

&lt;p&gt;Huge thanks to Crypt32 and davenpcj from Server Fault for first &lt;a href=&quot;https://serverfault.com/questions/670725/is-it-possible-to-restrict-the-use-of-a-root-certificate-to-a-domain&quot;&gt;cluing me in&lt;/a&gt; that this approach would work.  Unfortunately, Crypt32 didn’t provide any sample code, and the sample code from davenpcj didn’t work as-is for me (OpenSSL kept returning various errors when I tried to cross-sign, most of which seemed to be because OpenSSL didn’t like the fact that the public CA hadn’t signed an authorization for me to cross-sign their CA).  I eventually managed to cobble together a Bash script using OpenSSL that did work, but I don’t think OpenSSL’s command-line tool is really the right tool for the job (OpenSSL tends to rewrite large parts of the cross-signed certificate in ways that are likely to cause compatibility and security problems).  I’m probably going to rewrite this as a Go program.&lt;/p&gt;

&lt;p&gt;Anyway, with my Bash script, I decided to apply a name constraint to &lt;code class=&quot;highlighter-rouge&quot;&gt;DST Root CA X3&lt;/code&gt;, which is the root CA that Let’s Encrypt uses.  The name constraint I applied blacklists the &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; TLD (obviously I can’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; for testing this, since no public CA’s are known to have issued a certificate for a &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domain).  And… it works!  The Bash script installed the local root CA as a trust anchor for p11-kit, installed the intermediate and cross-signed CA’s as trust-neutral certificates for p11-kit, and installed a copy of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;DST Root CA X3&lt;/code&gt; certificate to the p11-kit blacklist.  As a result, both Chromium and Firefox still work fine with Let’s Encrypt for &lt;code class=&quot;highlighter-rouge&quot;&gt;.com&lt;/code&gt; websites such as &lt;a href=&quot;https://tehnoetic.com/&quot;&gt;Technoethical&lt;/a&gt;, but return an error for &lt;code class=&quot;highlighter-rouge&quot;&gt;.org&lt;/code&gt; websites such as &lt;a href=&quot;https://www.namecoin.org/&quot;&gt;Namecoin.org&lt;/a&gt; – exactly the behavior we want.&lt;/p&gt;

&lt;p&gt;I also made a modified version of my Bash script that installs the modified CA’s into a standard NSS sqlite3 database (without p11-kit), and confirmed that this works with both Firefox and Chromium on GNU/Linux.  So p11-kit probably won’t be a hard dependency of this approach, meaning that this approach is likely to work for Firefox on all OS’s, Chromium on all GNU/Linux distros, and anything else that uses NSS.&lt;/p&gt;

&lt;p&gt;This code needs a lot of cleanup before it’s ready for release; among the ToDos are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Port the certificate handling code to a Go program instead of OpenSSL’s command line.&lt;/li&gt;
  &lt;li&gt;Automatically detect which root CA’s exist in p11-kit, and apply the name constraint to all of them, instead of only using &lt;code class=&quot;highlighter-rouge&quot;&gt;DST Root CA X3&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Automatically detect when a public root CA is deleted from p11-kit (e.g. WoSign), and remove the name-constrained CA that corresponds to it.&lt;/li&gt;
  &lt;li&gt;Preserve p11-kit’s attached attributes for trust anchors.&lt;/li&gt;
  &lt;li&gt;Make the procedure idempotent.&lt;/li&gt;
  &lt;li&gt;Test whether this works as intended for other p11-kit-supported libraries (Firefox and Chromium use NSS; p11-kit also supports OpenSSL, Java, and GnuTLS among others).&lt;/li&gt;
  &lt;li&gt;Test whether a similar approach with name constraints can work for CryptoAPI (this would be relevant for most non-Mozilla browsers on Windows).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m hopeful that this work will allow us to continue supporting Chromium on GNU/Linux after Chromium removes HPKP, and that it will nicely complement the Firefox positive override support &lt;a href=&quot;/2018/02/20/ncdumpzone-firefox.html&quot;&gt;that I added to &lt;code class=&quot;highlighter-rouge&quot;&gt;ncdumpzone&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It should be noted that this approach definitely will not work on most non-Mozilla macOS browsers, because macOS’s TLS implementation does not support name constraints.  I’m not aware of any practical way to do negative overrides on macOS (besides the deprecated HPKP support in Chromium), so there’s a chance that when we get around to macOS support, we’ll just not do negative overrides for macOS (meaning that while Namecoin certificates would work on macOS without errors, malicious public CA’s would still be able to do MITM attacks against macOS users just like they can for DNS domain names).  Firefox on macOS shouldn’t have this problem, since Firefox doesn’t use the OS for certificate verification.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Mar 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/03/11/p11-kit-negative-overrides.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/03/11/p11-kit-negative-overrides.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Adding a Firefox TLS Mode to ncdumpzone</title>
        <description>&lt;p&gt;Firefox stores its list of certificate overrides in a text file.  While it’s not feasible to edit this text file while Firefox is running (Firefox only loads it on startup) I’ve experimentally found that it is completely feasible to create positive overrides if you shut off Firefox while the override is being created.  But is this a reasonable expectation for Namecoin?  Actually yes.  Here’s how we’re doing it:&lt;/p&gt;

&lt;p&gt;Note that most Namecoin users are doing name lookups via one of the following clients:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Namecoin Core (in full node mode)&lt;/li&gt;
  &lt;li&gt;Namecoin Core (in pruned mode)&lt;/li&gt;
  &lt;li&gt;libdohj-namecoin (in &lt;code class=&quot;highlighter-rouge&quot;&gt;leveldbtxcache&lt;/code&gt; mode)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These have an important feature in common: they all keep track of the UNO (unspent name output) set locally.  That means that you don’t need to wait for a DNS lookup to be hooked before you process a TLSA record from the blockchain – you can process TLSA records in advance, before Firefox even boots!&lt;/p&gt;

&lt;p&gt;Note that the above is not true for the following cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;libdohj-namecoin (in API server mode)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains that are delegated to a DNSSEC server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, what we need is a tool that walks the entire Namecoin UNO set, processes each name, and writes out some data about the TLSA records.  Coincidentally, this is very similar to what &lt;code class=&quot;highlighter-rouge&quot;&gt;ncdumpzone&lt;/code&gt; does.  &lt;code class=&quot;highlighter-rouge&quot;&gt;ncdumpzone&lt;/code&gt; is a utility distributed with ncdns.  It exports a DNS zonefile of the &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; zone, which is intended for users who for some reason want to use BIND as an authoritative nameserver instead of using ncdns directly.  However, with some minimal tweaking, we can make &lt;code class=&quot;highlighter-rouge&quot;&gt;ncdumpzone&lt;/code&gt; export the &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; zone in some other format… such as a Firefox certificate override list format.&lt;/p&gt;

&lt;p&gt;For example, this command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./ncdumpzone --format=firefox-override --rpcuser=user --rpcpass=pass &amp;gt; firefox.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Resulted in the following file being saved:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nf.bit:443	OID.2.16.840.1.101.3.4.2.1	13:E7:03:D6:A2:70:1E:77:41:21:F5:84:6D:3E:0B:FD:5F:00:B7:6B:47:96:82:E3:A2:B0:54:A0:25:76:0A:1A	U	AAAAAAAAAAAAAAAAAAAAAA==
test.veclabs.bit:443	OID.2.16.840.1.101.3.4.2.1	66:86:29:37:ED:53:B3:CE:2B:9B:A5:30:4D:59:83:35:4C:EC:80:9A:1F:39:DC:37:87:6E:00:4B:AF:08:3E:BA	U	AAAAAAAAAAAAAAAAAAAAAA==
www.aoeu2code.bit:443	OID.2.16.840.1.101.3.4.2.1	13:E3:2D:1B:05:B5:DC:57:94:3D:17:EC:99:25:3F:AF:54:87:7E:62:FC:51:18:06:B7:F4:87:51:62:3A:3B:1C	U	AAAAAAAAAAAAAAAAAAAAAA==
markasoftware.bit:443	OID.2.16.840.1.101.3.4.2.1	43:B4:EA:FC:FF:25:CC:85:A9:3D:CE:75:55:31:C9:DB:60:AF:06:C3:65:E5:28:62:08:20:DD:62:F4:70:0E:7D	U	AAAAAAAAAAAAAAAAAAAAAA==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These 4 lines correspond to the only 4 TLSA records that exist in the Namecoin blockchain right now.  Obviously, the first part of each line is the domain name and port of the website.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OID.2.16.840.1.101.3.4.2.1&lt;/code&gt; signifies that the fingerprint uses the SHA256 algorithm.  (This is the only one that Firefox has ever supported, but Firefox is designed to be future-proof in case a newer hash function becomes necessary.)  Next comes the fingerprint itself, in uppercase colon-delimited hex.  &lt;code class=&quot;highlighter-rouge&quot;&gt;U&lt;/code&gt; indicates that the positive override is capable of overriding an “untrusted” error (it can’t override validity period or domain name mismatch errors).  The interesting part is &lt;code class=&quot;highlighter-rouge&quot;&gt;AAAAAAAAAAAAAAAAAAAAAA==&lt;/code&gt;, which Mozilla’s source code refers to as a &lt;code class=&quot;highlighter-rouge&quot;&gt;dbKey&lt;/code&gt;.  Mozilla’s source code always calculates this using the issuer and serial number of the certificate.  However, empirically it works just fine if I instead use all 0’s (in the same base64 encoding).  Looking at the Mozilla source code, the dbKey isn’t actually utilized in the process of checking whether an override exists.  I’m not certain exactly what Mozilla is using it for (it seems to be used in a code path that’s related to enumerating all the overrides that exist).  Since the issuer and serial number aren’t always derivable from TLSA records (you generally need either a dehydrated certficate or a full certificate for this; my goal here is to work even if only the SHA256 fingerprint of a cert is known), we just set it to all 0’s.&lt;/p&gt;

&lt;p&gt;Copying the above output into Firefox’s cert override file, and then starting up Firefox, I was able to access &lt;a href=&quot;https://nf.bit/&quot;&gt;the Namecoin forum’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domain&lt;/a&gt; without any TLS errors.  I’ve submitted a PR to ncdns.&lt;/p&gt;

&lt;p&gt;While I was writing this code, I noticed that ncdns was actually calculating TLSA records incorrectly.  One of the bugs in TLSA record calculation was already known (&lt;a href=&quot;https://github.com/namecoin/ncdns/issues/59&quot;&gt;Jefferson Carpenter reported it last month&lt;/a&gt;), while the other was unnoticed (the TLSA records contained a rehydrated certificate that accidentally included a FQDN as the domain name; the erroneous trailing period caused the signatures and fingerprints to fail verification).  The fact that these bugs in my TLSA code remained unnoticed for about a year seems to be evidence that no one is actually using TLSA over DNS with Namecoin in the real world; the only Namecoin TLS users are using ncdns’s &lt;code class=&quot;highlighter-rouge&quot;&gt;certinject&lt;/code&gt; feature, which did not have this bug.&lt;/p&gt;

&lt;p&gt;It should be noted that this approach isn’t secure in the sense that Namecoin TLS with Chromium is, because it doesn’t provide negative overrides (meaning that a public CA could issue a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; certificate that wouldn’t be blocked by this method).  However, positive and negative overrides are mostly orthogonal goals in terms of implementation, so this is huge progress while we wait for proper WebExtensions support for TLS overrides.  I also think it’s likely to be feasible to implement negative overrides using NSS, in a way that Firefox will honor.  More on that in a future post.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/02/20/ncdumpzone-firefox.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/02/20/ncdumpzone-firefox.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Positive TLS Certificate Overrides for NSS</title>
        <description>&lt;p&gt;NSS is the TLS implementation used by various applications, including Chromium on GNU/Linux and Firefox on all platforms.  I’ve finished initial support for positive cert overrides in NSS, and have submitted a PR that is now awaiting review.&lt;/p&gt;

&lt;p&gt;I had previously written a WIP PR that implemented positive overrides for NSS, but it worked by using an NSS database directory that was auto-detected based on the active user’s home directory.  This seemed like a clever usability trick, but it had 2 severe disadvantages:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Some applications don’t use the shared NSS database, but instead use their own.  Firefox is one of these applications.&lt;/li&gt;
  &lt;li&gt;For security reasons, we want ncdns to run as its own user with restricted permissions.  This would break the database directory auto-detection.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The new PR has explicit configuration options for which NSS database directory is used.  For example, the following command line config:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./ncdns -ncdns.namecoinrpcusername=user -ncdns.namecoinrpcpassword=pass -certstore.nss -certstore.nsscertdir=&quot;$(pwd)&quot;/certs -certstore.nssdbdir=/home/user/.pki/nssdb -xlog.severity=DEBUG
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Allowed &lt;a href=&quot;https://nf.bit/&quot;&gt;the Namecoin Forum’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domain&lt;/a&gt; to load in Chromium in my Fedora VM without any TLS errors.  Obviously, this would need to be combined with the negative override functionality provided by the &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_chromium_tool&lt;/code&gt; program (included with ncdns) in order to actually have reasonable security (otherwise, public TLS CA’s could issue &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; certs that would still be accepted by Chromium).&lt;/p&gt;

&lt;p&gt;Some remaining challenges:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NSS’s &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; is extremely slow, due to failure to properly batch operations into sqlite transactions.  I’ve filed a bug about this with Mozilla.  Until this is fixed, expect an extra ~800ms of latency when accessing Namecoin HTTPS websites.  Possible future workarounds:
    &lt;ul&gt;
      &lt;li&gt;Run &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; sometime before the DNS hook, so that 800ms of latency isn’t actually noticeable for the user.  (More on this in a future post.)&lt;/li&gt;
      &lt;li&gt;Do some highly horrifying &lt;code class=&quot;highlighter-rouge&quot;&gt;LD_PRELOAD&lt;/code&gt; witchcraft in order to fix the crappy sqlite usage.&lt;/li&gt;
      &lt;li&gt;Use a different pkcs11 backend instead of NSS’s sqlite3 backend.  (Yes, NSS uses pkcs11 behind the scenes.  More on this in a future post.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Firefox doesn’t actually respect NSS’s trust anchors when the trust anchor is an end-entity certificate.  Possible future workarounds:
    &lt;ul&gt;
      &lt;li&gt;Use a Firefox-specific positive override mechanism.  (More on this in a future post; also see the WebExtensions posts.)&lt;/li&gt;
      &lt;li&gt;Inject CA certs rather than end-entity certs.  (More on this in a future post.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Some NSS applications don’t use the sqlite backend, but instead use BerkeleyDB as a backend.  BerkeleyDB can’t be opened concurrently by multiple applications, so ncdns can’t inject certs while another application is open.  Possible future workarounds:
    &lt;ul&gt;
      &lt;li&gt;Use an environment variable to force sqlite usage.&lt;/li&gt;
      &lt;li&gt;Run &lt;code class=&quot;highlighter-rouge&quot;&gt;certutil&lt;/code&gt; while the database isn’t open.&lt;/li&gt;
      &lt;li&gt;Use a different pkcs11 backend.&lt;/li&gt;
      &lt;li&gt;Wait for those applications to switch to sqlite.  (Firefox switched in Firefox 58, and it appears more applications may follow suit.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That said, despite the need for future work, this PR makes Namecoin TLS fully functional in Chromium on GNU/Linux.  (Until negative overrides stop working due to HPKP being removed… more on potential fixes in a future post.)&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/02/18/positive-tls-overrides-for-nss.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/02/18/positive-tls-overrides-for-nss.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin TLS for Firefox: Phase 6 (Negative Override Cache in C++, WebExtension Aggregation, and Coordination with Mozilla)</title>
        <description>&lt;p&gt;In &lt;a href=&quot;/2017/10/29/firefox-tls-moving-cache-cpp.html&quot;&gt;Phase 5&lt;/a&gt; of Namecoin TLS for Firefox, I discussed the performance benefits of moving the positive override cache from JavaScript to C++.  I’ve now implemented preliminary work on doing the same for negative overrides.&lt;/p&gt;

&lt;p&gt;The code changes for negative overrides’ C++ cache are analogous to those for positive overrides, so there’s not much to cover in this post about those changes.  However, I did take the chance to refactor the API between the C++ code and the JavaScript code a bit.  Previously, only 1 WebExtension was able to perform overrides; if multiple WebExtensions registered for the API, whichever replied first would be the only one that had any effect.  Now, each WebExtension replies separately to the Experiment, and the Experiment passes those replies on to the C++ code.  The Experiment also notifies the C++ code when all of the WebExtensions have replied.  Although this does add some extra API overhead, it has the benefit of allowing an override to take place immediately if a single WebExtension has determined that it should take place, even if the other (irrelevant) WebExtensions are still evaluating the certificate.&lt;/p&gt;

&lt;p&gt;Unfortunately, at this point I merged upstream changes from Mozilla into my Mercurial repository, only to find that there was now a compile error.  I’m still figuring out exactly why this compile error is happening.  It looks like it’s unrelated to any of the files that my patch touches; I suspect that it’s due to my general lack of competence with Mercurial (Mozilla’s codebase is the first time I’ve used Mercurial) or my similar general lack of competence with Mozilla’s build system.&lt;/p&gt;

&lt;p&gt;So, until I actually get the code to build, I won’t be able to do performance evaluations of these changes.  Hence why there are no pretty graphs in this post.&lt;/p&gt;

&lt;p&gt;Meanwhile, I reached out to Mozilla to get some feedback on the general approach I was taking.  (I had previously discussed high-level details with Mozilla, but this time I provided a WIP code patch, so that it would be easier to evaluate whether I was doing anything with the code that would be problematic.)  This resulted in a discussion about what methods should be used to prevent malicious or buggy extensions from causing unexpected damage to user security.  This is definitely a legitimate concern: messing with certificate verification is dangerous when done improperly, and it’s important that users understand what they’re getting when they install a WebExtension that might put them at risk.  That discussion is still ongoing, and it’s not clear yet what the consensus will arrive at.&lt;/p&gt;

&lt;p&gt;(It should be noted that there are some alternative approaches to Firefox support for Namecoin TLS underway as well, which will be covered in a future post.)&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/02/13/firefox-tls-negative-cache.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/02/13/firefox-tls-negative-cache.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Pruning of Non-scriptPubKey Data in libdohj</title>
        <description>&lt;p&gt;Our lightweight SPV client’s &lt;code class=&quot;highlighter-rouge&quot;&gt;leveldbtxcache&lt;/code&gt; mode is the most secure of the various Namecoin lightweight SPV modes.  Its storage requirements aren’t too bad either (129.1 MB at the moment for Namecoin mainnet).  However, while 129.1 MB of storage isn’t a dealbreaker, it’s still a bit borderline on mobile devices.  We can do better.&lt;/p&gt;

&lt;p&gt;First, a reminder of how &lt;code class=&quot;highlighter-rouge&quot;&gt;leveldbtxcache&lt;/code&gt; currently works.  Initially, the IBD (initial blockchain download) proceeds the same way a typical lightweight SPV Bitcoin client (such as Schildbach’s Android Bitcoin Wallet) would work: it downloads blockchain headers, aiming for the chain with the most work.  However, at the point when the IBD has reached 1 year ago in the blockchain, it begins downloading full blocks instead of block headers.  The full blocks aren’t saved; they’re used temporarily for 2 purposes: verifying consistency with the block headers’ Merkle root (thus ensuring that no transactions have been censored), and adding any &lt;code class=&quot;highlighter-rouge&quot;&gt;name_anyupdate&lt;/code&gt; transactions to a LevelDB database that allows quick lookup of names.  After those 2 things have been processed, the full blocks are discarded.  The 129.1 MB storage figure is as low as it is because we’re only storing name transactions from the last year (plus block headers, which are negligible in size).&lt;/p&gt;

&lt;p&gt;However, there’s a lot of data in name transactions that we don’t actually need in order to look up names: currency data, signatures, and transaction metadata.&lt;/p&gt;

&lt;p&gt;Currency data exists in name transactions because name operations cost a transaction fee, so there will typically be a currency input and a currency output in any name transaction.  We don’t need this information in order to look up names.  Signatures are used for verifying new transactions, but are not needed to look up previously accepted transaction data.  Transaction metadata, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;nLockTime&lt;/code&gt;, is also not needed to look up names.  There may be other sources of unwanted data too.&lt;/p&gt;

&lt;p&gt;To improve the situation, I’ve just modified &lt;code class=&quot;highlighter-rouge&quot;&gt;leveldbtxcache&lt;/code&gt; so that, instead of storing full name transactions in LevelDB, it only stores the &lt;code class=&quot;highlighter-rouge&quot;&gt;scriptPubKey&lt;/code&gt; of the name output.  This includes the name’s identifier and value, as well as the Bitcoin-compatible &lt;code class=&quot;highlighter-rouge&quot;&gt;scriptPubKey&lt;/code&gt; that can be used to verify future signatures.  It’s a relatively straightforward change to the code, although it does break backward-compatibility with existing name databases (so you’ll need to delete your blockchain and resync after updating).&lt;/p&gt;

&lt;p&gt;So, how does this fare?&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Full Transactions&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Only &lt;code class=&quot;highlighter-rouge&quot;&gt;scriptPubKey&lt;/code&gt;&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Storage Used after IBD&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;129.1 MB&lt;/td&gt;
      &lt;td&gt;63.7 MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Time Elapsed for IBD&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;~9 Minutes&lt;/td&gt;
      &lt;td&gt;~6 minutes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Not bad, and we even got a faster IBD as a bonus.  (This suggests that the bottleneck, at least on my laptop running Qubes with an HDD, was storage I/O.)&lt;/p&gt;

&lt;p&gt;I’ve just submitted this change to upstream libdohj.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/02/11/libdohj-pruning-scriptpubkey.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/02/11/libdohj-pruning-scriptpubkey.html</guid>
        
        <category>News</category>
        
        
      </item>
    
  </channel>
</rss>
