<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namecoin</title>
    <description><!--Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
--></description>
    <link>https://namecoin.org//</link>
    <atom:link href="https://namecoin.org//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 09 Oct 2018 11:08:06 +0000</pubDate>
    <lastBuildDate>Tue, 09 Oct 2018 11:08:06 +0000</lastBuildDate>
    <generator>Jekyll v3.6.0</generator>
    
      <item>
        <title>Electrum-NMC: Name Update GUI</title>
        <description>&lt;p&gt;I previously wrote about &lt;a href=&quot;/2018/10/03/electrum-nmc-name-transaction-creation.html&quot;&gt;creating name transactions in the Electrum-NMC console&lt;/a&gt;.  Next up, adding GUI support.&lt;/p&gt;

&lt;p&gt;The new &lt;code class=&quot;highlighter-rouge&quot;&gt;Renew Name&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure Name...&lt;/code&gt; buttons use the previously discussed &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; command as their backend, which makes implementation relatively simple, since it’s not difficult for GUI functions to access console commands.  I facilitated the &lt;code class=&quot;highlighter-rouge&quot;&gt;Renew Name&lt;/code&gt; command by making the &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; parameter of &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; optional; if not supplied, it will be set to the current value of the name.&lt;/p&gt;

&lt;p&gt;However, this introduces an interesting attack scenario: if an ElectrumX server falsely reports the current value of a name you own and you click the Renew button, you would be tricked into signing a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; transaction that contains the malicious value.  Therefore, to mitigate this scenario, &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; is only optional if the latest transaction for the name has at least 12 confirmations.  I can’t picture any way that this mitigation would cause real-world UX problems; presumably no one wants to renew a name that was already last updated fewer than 12 blocks ago.&lt;/p&gt;

&lt;p&gt;One nice UX improvement in Electrum-NMC compared to Namecoin-Qt is that you can renew multiple names at once: just select more than one name in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Manage Names&lt;/code&gt; tab, and then click &lt;code class=&quot;highlighter-rouge&quot;&gt;Renew Name&lt;/code&gt;.  Implementing this was a bit tricky, because Electrum’s coin selection algorithm doesn’t normally notice that a coin has been spent until it receives a copy from the ElectrumX server, which is usually a few seconds after we broadcast it to the ElectrumX server.  As a result, the coin selection algorithm would try to double-spend the same currency input for each name renewal.  I fixed this by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;addtransaction(tx)&lt;/code&gt; (which adds a transaction to the wallet) immediately after &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast(tx)&lt;/code&gt; returns success, before moving on to the the next name to renew.&lt;/p&gt;

&lt;p&gt;It should be noted that renewing multiple names at once will probably reveal to blockchain deanonymizers that the affected names have common ownership.  So, while this feature is potentially useful, it should be used with care.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure Name...&lt;/code&gt; button and associated dialog were relatively uneventful in terms of bugs.  That said, it did occur to me that it might be better to re-use Namecoin-Qt’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.ui&lt;/code&gt; form files for this purpose instead of re-implementing the dialog in Python.  Unfortunately, Namecoin-Qt’s form files are a bit too specific to Bitcoin Core (e.g. they incorporate widgets that only exist in Bitcoin Core, which have different implementations in Electrum).  I think it would be plausible to improve the abstraction of Namecoin-Qt’s form files so that we could re-use them in Electrum-NMC and save on duplicated GUI effort; hopefully something will happen there after higher-priority tasks are dealt with in the Namecoin-Qt codebase.&lt;/p&gt;

&lt;p&gt;And now, screenshots!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-06-Manage-Names-Tab.png&quot; alt=&quot;A screenshot of the &amp;quot;Renew Name&amp;quot; and &amp;quot;Configure Name...&amp;quot; buttons visible in the Electrum-NMC Manage Names tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-06-Configure-Name-Dialog.png&quot; alt=&quot;A screenshot of the &amp;quot;Configure Name&amp;quot; dialog in Electrum-NMC.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/09/electrum-nmc-name-update-gui.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/09/electrum-nmc-name-update-gui.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: Name Transaction Creation</title>
        <description>&lt;p&gt;In a previous article, I wrote about &lt;a href=&quot;/2018/10/04/electrum-nmc-name-script-deserialization-round-2.html&quot;&gt;the “reading” side of Electrum-NMC’s name script support&lt;/a&gt; (i.e. detecting and displaying name transactions in the wallet, and doing name lookups).  Obviously, the logical next step is the “writing” side, i.e. creating name transactions.&lt;/p&gt;

&lt;p&gt;I started out by trying to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt;.  Electrum’s command API is quite flexible (yet quite user-friendly), so most of the relevant functionality was fairly straightforward to implement by adding slight modifications to the existing transaction creation commands.  These modifications essentially just add an extra output to the transaction that has a non-null name operation.  I did, however, need to add some extra functionality to the accounting, to adjust for the fact that a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction destroys 0.01 NMC by permanently locking it inside an output.  (Usually, it’s desirable to treat that locked namecent as zero for display purposes, but when funding a transaction, treating it as zero would produce Bad Things ™.)&lt;/p&gt;

&lt;p&gt;Electrum’s API philosophy differs from that of Bitcoin Core, in that while Bitcoin Core wallet commands tend to broadcast the result automatically, Electrum wallet commands tend to simply return a transaction, which you’re expected to broadcast with the &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt; command.  I’m following this approach for the name wallet commands.  Creating the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction completed rather easily without errors; however, when I tried to broadcast the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction, it was rejected by my Namecoin Core node that serves as the backend for my ElectrumX instance.  I inspected my Namecoin Core node’s &lt;code class=&quot;highlighter-rouge&quot;&gt;debug.log&lt;/code&gt;, and quickly found the issue: I had forgotten to set the transaction’s &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; field to the value that permits name operations.  Namecoin requires all name operations to appear in transactions with an &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; field of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7100&lt;/code&gt;, which is a value that doesn’t show up in Bitcoin at all.  I decided not to modify the transaction construction API’s in Electrum to allow manual setting of the &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; field per command (end users don’t want to think about these details), and instead decided that it was easier to simply add a couple of lines to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Transaction&lt;/code&gt; class so that if you supply it with an output that has a name operation attached to it, the resulting transaction will automatically have its &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; modified.&lt;/p&gt;

&lt;p&gt;With that fix, I could create &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions and broadcast them.  I sent a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; from Electrum-NMC to my Namecoin Core wallet and also created one that stayed within Electrum-NMC.  The underlying logic here was two-fold: (1) I wanted to make sure that both explicitly-specified recipient addresses and automatically-generated local addresses worked properly, and (2) if an issue happened while trying to spend the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; outputs with Electrum-NMC, I wanted to be able to quickly compare the results with Namecoin Core so that I would know whether the problem was with the code trying to spend the output or with the code that created the output.&lt;/p&gt;

&lt;p&gt;While both &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions were reaching their required 12 blocks of confirmations, I implemented &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; support.  This was a little bit more interesting, because it meant I had to explicitly add a mandatory name &lt;strong&gt;input&lt;/strong&gt; (the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt;) in addition to a mandatory name &lt;strong&gt;output&lt;/strong&gt; (the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt;).  Electrum makes it very easy to add mandatory outputs, since that’s commonplace in Bitcoinland.  Adding mandatory inputs, however, is not exactly straightforward.  I ended up modifying a few of the coin selection algorithms to allow specifying mandatory inputs that would be applied before any other inputs are added, and while I wish it could be done with fewer changes, I’m reasonably happy with the result.&lt;/p&gt;

&lt;p&gt;Creating the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transaction was relatively easy to do from Electrum-NMC without errors.  Unfortunately, once again the transaction was rejected by my ElectrumX instance’s Namecoin Core node.  This time the error was a lot less intelligible; the error had something to do with the signature check failing, but it wasn’t clear to me exactly what the problem was.  To narrow down the issue, I tried spending the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; that I had sent to my Namecoin Core wallet into a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt;, and that one worked fine.  So clearly the issue was in the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; code in Electrum-NMC, and not anything broken in the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; that was already created.  I ended up copying the invalid transaction into Namecoin Core’s &lt;code class=&quot;highlighter-rouge&quot;&gt;decoderawtransaction&lt;/code&gt; RPC method, and then pasting the hex-encoded script into &lt;a href=&quot;https://siminchen.github.io/bitcoinIDE/build/editor.html&quot;&gt;Bitcoin IDE&lt;/a&gt; to simulate exactly what was happening.  And it definitely was clear that something was wrong: the hash that the signature signed didn’t match the hash it was supposed to be signing.&lt;/p&gt;

&lt;p&gt;This seemed rather weird, since I hadn’t touched any of the signature code.  After some grep-fu of the Electrum codebase, I figured out what had happened.  In Bitcoin transactions, the signatures cover the scriptPubKeys of the previous transaction outputs.  This shouldn’t be a problem, but Electrum tries to be clever in order to avoid actually looking up the previous transactions.  Electrum actually guesses the previous scriptPubKey based on the scriptSig.  This actually works fine for the transaction types that one normally finds in Bitcoinland.  However, in Namecoin, name operations are prefixed to the scriptPubKey, and nothing about that name prefix (even whether one exists at all) can be inferred from the scriptSig that spends the name output.  As a result, the previous scriptPubKey that was being signed didn’t have a name prefix at all, which of course caused the hashes to mismatch.&lt;/p&gt;

&lt;p&gt;Modifying the wallet code to pass through name operations to the data structures that the scriptPubKey-guessing code has access to wasn’t particularly painful, nor was modifying the scriptPubKey-guessing code to prefix the correct name script when needed.  With that out of the way, a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; from Electrum-NMC was able to broadcast successfully.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; was comparatively simple.  The main change needed for this one was that while &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; specified the mandatory name input by TXID, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; specifies it by name identifier.  Adding this functionality to the coin selection algorithms wasn’t particularly unpleasant.  And thus, I was able to create and broadcast a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; transaction as well.  Yay!&lt;/p&gt;

&lt;p&gt;The next future step is probably to hook these commands into the GUI.&lt;/p&gt;

&lt;p&gt;And, with that out of the way, here are some transactions I created with Electrum-NMC’s console:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/9204de3739850d6e0c9c8a5a838747485c1dabddc319a8abfc83f004694e3723&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; created by Electrum-NMC, sent to Namecoin Core&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/804631725e80ff334fecb8fba85ddbb76ede99ba36d951dac5ab41cb462a375f&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; created by Namecoin Core, spending the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; created by Electrum-NMC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/317c6391c94a14c0d777b56b6b31ff1124ce8a6c98874a447239a654f605018a&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; created by Electrum-NMC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/978122fd205d2f87b333b433af51b2e0f9b67ed9b6270d2fa2cbb013e30c0ffd&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; created by Electrum-NMC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/06/electrum-nmc-name-transaction-creation.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/06/electrum-nmc-name-transaction-creation.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Halving Day (Block 420000)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/block/420000&quot;&gt;Block number 420000&lt;/a&gt; (hash &lt;code class=&quot;highlighter-rouge&quot;&gt;145f72ea59018ca4117015e3c25a2ed24e22e67c948841dd46a200db11d778be&lt;/code&gt;) was mined at &lt;code class=&quot;highlighter-rouge&quot;&gt;2018-10-04 01:10:19 +0000&lt;/code&gt; by Slush Pool with a block reward of 12.5 NMC plus fees.  From all of us at Namecoin, Happy Halving Day, everyone!&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Oct 2018 02:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/04/halving-day.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/04/halving-day.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: Name Script Deserialization (Round 2: Name History Display, Name Lookups, and Manage Names Tab)</title>
        <description>&lt;p&gt;I previously wrote about some work on &lt;a href=&quot;/2018/08/06/electrum-nmc-name-script-deserialization.html&quot;&gt;making Electrum-NMC handle name scripts&lt;/a&gt;.  In the last few days I hacked on that code some more.&lt;/p&gt;

&lt;p&gt;As you may have noticed from the screenshot in the previous article, I’m initially testing this code with watching-only wallets, since there are fewer moving parts there and I don’t have to worry about constructing and signing transactions.  When looking for addresses to add to the watching-only wallet, I usually just look through the &lt;a href=&quot;https://namecoin.cyphrs.com/&quot;&gt;Cyphrs block explorer&lt;/a&gt; and take the first few name transactions that show up of each desired type.  Interestingly, I noticed that a subset of the name transactions I picked from the explorer this time weren’t visible in the Electrum-NMC GUI.  Some querying of my ElectrumX server indicated that the transactions were definitely being delivered to Electrum-NMC, and inspecting Electrum-NMC’s wallet file showed that the transactions were definitely being added to the wallet.  But for some reason, Electrum-NMC wasn’t displaying them.&lt;/p&gt;

&lt;p&gt;After quite a lot of tracing through the code, I figured out that the transactions in question had name scripts that weren’t successfully being recognized as name scripts.  Some more tracing led me to figure out that the code was failing to parse any &lt;code class=&quot;highlighter-rouge&quot;&gt;name_anyupdate&lt;/code&gt; script whose value was the empty string.  Turns out that upstream Electrum has a wildcard-like script matching function that can detect arbitrary data pushes (which I was using) – but for some reason they don’t treat &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_0&lt;/code&gt; as a data push for the purpose of that wildcard matching.  Pushing the empty string to the stack is implemented by… you guessed it, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_0&lt;/code&gt;.  I filed a GitHub issue with upstream Electrum about this, and it looks like they’ve fixed it upstream (quite quickly, too).  While I was waiting for them to fix it, I did implement a (very hacky) workaround in Electrum-NMC’s name script parser, but that workaround will most likely be removed (yay!) when I next merge from upstream Electrum.  Kudos to the upstream Electrum devs on this; they’ve consistently been quite helpful (and quick) at implementing fixes that make life easier for downstream projects like Electrum-NMC.&lt;/p&gt;

&lt;p&gt;I had previously implemented some special UI code for displaying that a name transaction is a transfer operation.  This is a UX improvement over Namecoin Core, which confusingly displays both incoming and outgoing name transfers identically to name updates.  I had defined a name transfer as “a name transaction for which the wallet owns a name input XOR the wallet owns a name output”.  Do you see a problem here?  Yeah, that definition matches &lt;strong&gt;all&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions where the wallet owns the output, because &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions &lt;em&gt;don’t have a name input&lt;/em&gt;.  D’oh.  Fixed that.&lt;/p&gt;

&lt;p&gt;Up next was displaying the name identifiers in the UI.  Again, I’m trying to improve on Namecoin Core’s UX here.  For example, I prefer to make &lt;code class=&quot;highlighter-rouge&quot;&gt;d/wikileaks&lt;/code&gt; show up as &lt;code class=&quot;highlighter-rouge&quot;&gt;wikileaks.bit&lt;/code&gt;.  My code also recognizes invalid &lt;code class=&quot;highlighter-rouge&quot;&gt;d/&lt;/code&gt; names, e.g. names with uppercase characters, and indicates that they’re not valid domain names.  Ditto for &lt;code class=&quot;highlighter-rouge&quot;&gt;id/&lt;/code&gt; names.  In addition, if the namespace is unknown or the identifier isn’t valid under the namespace rules, I actually check whether the identifier consists entirely of ASCII printable characters.  If it does, I print it in ASCII; if it doesn’t, I print it in hex.  Similar checks are in place for values.  The Namecoin consensus rules have always allowed binary data to exist in identifiers and values, but the UI for this functionality was pretty much always missing.  Electrum-NMC should handle this kind of thing without trouble.  One practical example of how this could be used in the future is storing values as CBOR rather than JSON.  CBOR is substantially more compact, especially when encoding binary data like TLS certificates, which means &lt;em&gt;moar scaling&lt;/em&gt; and &lt;em&gt;moar savings on transaction fees&lt;/em&gt;.  (CBOR also seems to be a common choice by the DNS community, including people at IETF and ICANN.)&lt;/p&gt;

&lt;p&gt;Then, I implemented the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; console command.  For readers unfamiliar with the Namecoin Core RPC API, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; is the command that &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; resolvers like ncdns use to look up name data from Namecoin Core and ConsensusJ-Namecoin.  My &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; implementation in Electrum-NMC includes SPV verification, just like Electrum’s history tab.  Every output JSON field from Namecoin Core is present, although currently none of the optional input fields are supported.  It probably wouldn’t be very difficult to hook this into ncdns.  However, it should be noted that Electrum’s SPV verification is a weaker security model than ConsensusJ-Namecoin’s leveldbtxcache SPV security model.  In addition, there’s only one public Namecoin ElectrumX server instance, so the concept of the “chain with most work” isn’t exactly meaningful.  Even so, it’s vastly more secure than centralized inproxies like OpenNIC, and it might be useful for some people.  Hopefully more people will step up to run public Namecoin ElectrumX servers so that the SPV security model can actually work as intended.&lt;/p&gt;

&lt;p&gt;Finally, I implemented a first pass at the Manage Names tab.  Display of the name identifier, value, and expiration block count are working.  This was a lot easier than implementing from scratch would be, because the Manage Names tab (referred to in the code as the UNO List widget) is actually just a subclass of the Coins tab (referred to in the code as the UTXO List widget).&lt;/p&gt;

&lt;p&gt;So, with that explanation out of the way, here’s what you really came here for: &lt;em&gt;screenshots!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-09-29-Names-in-History-Tab.png&quot; alt=&quot;A screenshot of name transactions visible in the Electrum-NMC History tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-09-29-Name-in-Transaction-Details.png&quot; alt=&quot;A screenshot of name data visible in the Electrum-NMC Transaction Details tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-09-29-Name-Show-in-Console-Tab.png&quot; alt=&quot;A screenshot of a name_show command's output in the Electrum-NMC Console tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-01-Manage-Names-Tab.png&quot; alt=&quot;A screenshot of the Electrum-NMC Manage Names tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/04/electrum-nmc-name-script-deserialization-round-2.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/04/electrum-nmc-name-script-deserialization-round-2.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>NSS certutil Windows rbm Build Scripts Submitted Upstream to The Tor Project</title>
        <description>&lt;p&gt;Previously, I covered &lt;a href=&quot;/2018/05/17/reproducible-builds-certutil-cross-compiling-rbm.html&quot;&gt;cross-compiling NSS certutil for Windows&lt;/a&gt; via Tor’s rbm build scripts.  Since I like to be a good neighbor, I’ve since reached out to the very nice people at Tor, and have submitted a patch to get this merged upstream.  I’ve already received a Concept ACK, although they cautioned me that they’re quite busy with other Tor Browser things at the moment and it may take a while for them to review my patch.  The Tor people requested that I consider adding macOS support as well; I’ve done so and that patch is also submitted to Tor for review.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/27/certutil-windows-rbm-submitted-tor-project.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/27/certutil-windows-rbm-submitted-tor-project.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>How Centralized Inproxies Make Everyone Less Safe (A Case Study)</title>
        <description>&lt;p&gt;Readers who have followed Namecoin for a while know that I’ve been sharply critical of centralized inproxies since I joined Namecoin development in 2013.  For readers who are unfamiliar with the concept, a centralized inproxy is a piece of infrastructure (run by a trusted third party) that allows users who aren’t part of a P2P network to access resources that are hosted inside that P2P network.  You can think of it as analogous to a web wallet in the Bitcoin world, except that whereas web wallets are for people who &lt;em&gt;own&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; websites, centralized inproxies are for people who &lt;em&gt;view&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; websites.  Centralized inproxies introduce security problems that are likely to be obvious to anyone familiar with the history of Bitcoin web wallets (I’m among the people who were around when &lt;em&gt;MyBitcoin&lt;/em&gt; existed but refused to use it; we were proven right when &lt;em&gt;MyBitcoin&lt;/em&gt; exit-scammed).&lt;/p&gt;

&lt;p&gt;However, for reasons that elude me, the concept of centralized inproxies seems to have an irritatingly persistent set of proponents.  It’s rare that a month goes by without having some rando on the Internet ask us to endorse, collaborate with, or develop a centralized inproxy (it’s only the 18th of this month as I write the first draft of this article, and it’s already happened twice this month).  I’ve personally been accused of trying to kill Namecoin via stagnation because I don’t support centralized inproxies.  The degree to which the advocacy for centralized inproxies is actually organic is dubious at best (there is evidence that at least one particularly loud and aggressive proponent of the concept has been motivated by undisclosed financial incentives).  However, regardless of how inorganic it may be, we encounter the request often enough that we actually added an entry to our FAQ about why we don’t support centralized inproxies.  In this post, I’d like to draw attention to the “Security concerns” section of that FAQ entry, specifically the 3rd bullet point:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;ISP’s would be in a position to censor names without easy detection.&lt;/li&gt;
    &lt;li&gt;ISP’s would be in a position to serve fraudulent PKI data (e.g. TLSA records), which would enable ISP’s to easily wiretap users and infect users with malware.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Either of the above security concerns would even endanger users who are running Namecoin locally, because it would make it much more difficult to detect misconfigured systems that are accidentally leaking Namecoin queries to the ISP.&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;The 3rd bullet point is intended as a debunking of the disturbingly common claim that “The security drawbacks only affect users who have opted into the centralized inproxy, and we would encourage users who care about security to install Namecoin locally.”  Even though I’ve been citing this concern for years, I had mostly been citing it in the sense of “This is going to burn someone eventually if centralized inproxies become widespread”; I hadn’t been citing it in the sense of “I personally have seen this happen in the wild.”&lt;/p&gt;

&lt;p&gt;Which brings us to a case study that I accidentally initiated recently.&lt;/p&gt;

&lt;p&gt;I was recently setting up a VM for Namecoin-related testing purposes.  In particular, this VM was to be used for some search-engine-related research (those of you who saw my science fair exhibit at the 2018 Decentralized Web Summit will be able to guess what I was doing).  I have a relatively standard procedure for setting up Namecoin VM’s, but admittedly I don’t do it very often.  I was particularly rusty in this case because I usually set up a Namecoin VM in Qubes/Xen, while this time I was using Debian/KVM (this is because my search engine needed a lot of RAM, meaning it was running on my Talos, and Qubes/Xen doesn’t run on the Talos yet).  Somehow, I managed to goof up the setup of the VM, and Namecoin resolution wasn’t actually running on it when I thought it was.  However, at the time I didn’t know this; it definitely looked like Namecoin was working.  I proceeded to do my search engine testing, and eventually (after about 30 minutes of clicking &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; links continuously) I noticed something odd.  I had clicked on a &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; link that I recalled (from previous testing many months prior) was misconfigured by the name owner, and therefore didn’t work in standards-compliant Namecoin implementations – but the name in question &lt;em&gt;did&lt;/em&gt; work in buggy inproxies like OpenNIC.  And, lo and behold, the link loaded without any errors in my VM.  My initial impression was to figure that maybe the name owner finally got around to fixing their broken name.  But I was curious to see when the change had been made, so I checked the name in the Cyphrs block explorer to see the transaction history of the name.  Hmm, that’s odd, no such fix ever was deployed.&lt;/p&gt;

&lt;p&gt;At this point, I was suspicious, so I started testing my network configuration.  And I discovered, to my surprise, that my &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; DNS traffic wasn’t being routed through ncdns and Namecoin Core – a network sysadmin upstream of my machine’s network connection had set their DNS to use OpenNIC’s resolver, and my &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; DNS traffic was being resolved by OpenNIC.&lt;/p&gt;

&lt;p&gt;Let’s look at some mitigating factors that helped me notice as quickly as I did:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I was visiting a wide variety of &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; sites from that VM; most users won’t be visiting many &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; sites.&lt;/li&gt;
  &lt;li&gt;I already had memorized a few &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains that had a broken configuration, and already knew that OpenNIC had incorrect handling of that broken configuration; most users have no idea how to identify a broken domain name configuration on sight (and certainly won’t have memorized a set of domains that have such configurations), and won’t have any knowledge of whatever obscure standards-compliance quirks exist in specific inproxy implementations.&lt;/li&gt;
  &lt;li&gt;I knew how to use a block explorer as a debugging tool; most users of Namecoin don’t use block explorers, just like most users of the DNS don’t use DNS “looking glass” tools.&lt;/li&gt;
  &lt;li&gt;I was able to walk down the hall to check with the network sysadmin, and knew exactly what question to ask him: “Is your network using OpenNIC’s DNS resolvers?”  Most users have never heard of OpenNIC, nor would they have any idea to ask such a question, nor would they necessarily be able to easily contact their network sysadmin, nor would they necessarily have a network sysadmin who would know the answer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Despite these substantial mitigating factors, it took me at least a half hour to notice.  That’s half an hour of web traffic that was trivially vulnerable to censorship and hijacking.  Would a typical user notice this kind of misconfiguration within a month?  I’m skeptical that they would.&lt;/p&gt;

&lt;p&gt;Now consider the threat models that a significant portion of the Internet’s users deal with.  For many Internet users (e.g. activists and dissidents), having the government be able to censor and hijack their traffic for a month without detection can easily lead to kidnapping, torture, and death.  There is a strong reason why the &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt; suTLD designation requires that DNS infrastructure (in particular, the ICANN root servers) return &lt;code class=&quot;highlighter-rouge&quot;&gt;NXDOMAIN&lt;/code&gt; for all &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt; domain names, rather than permitting ICANN or DNS infrastructure operators to run inproxies for &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt;.  That reason is that it is important for users of misconfigured systems to quickly notice that something is broken, rather than to have the system silently fall back to an insecure behavior that still looks on the surface like it works.  IETF and ICANN are doing exactly the right thing by making sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt; stays secure so that at-risk users don’t get murdered.  The draft spec for adding &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; as a suTLD (along with I2P’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.i2p&lt;/code&gt; and GNUnet’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.gnu&lt;/code&gt;) made the same guarantees (and ICANN is currently doing the right thing for &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; by not having allocated it as a DNS TLD).&lt;/p&gt;

&lt;p&gt;For me, the experience of accidentally using a centralized inproxy was primarily a waste of under an hour of my time, and a bit of embarrassment.  (Also, my network sysadmin promptly dropped OpenNIC from his configuration when I told him of the incident.)  But I hope that the community can take this as a learning opportunity, to better appreciate the inevitability of something catastrophic eventually happening if centralized inproxies are allowed to proliferate.  Let’s not be the project that ends up getting one of our users killed as collateral damage in a quest for rapidly-deployed ease-of-use.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/24/how-centralized-inproxies-make-everyone-less-safe-case-study.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/24/how-centralized-inproxies-make-everyone-less-safe-case-study.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core 0.16.3 Released</title>
        <description>&lt;p&gt;Namecoin Core 0.16.3 has been released on the &lt;a href=&quot;/download/#namecoin-core-client-stable-release&quot;&gt;Downloads page&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/22/namecoin-core-0.16.3-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/22/namecoin-core-0.16.3-released.html</guid>
        
        <category>Releases</category>
        
        <category>Namecoin Core Releases</category>
        
        
      </item>
    
      <item>
        <title>ConsensusJ-Namecoin v0.3.1 Released</title>
        <description>&lt;p&gt;We’ve released ConsensusJ-Namecoin v0.3.1.  Here’s what’s new:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Some of the Namecoin-specific code has been merged upstream to ConsensusJ, and has therefore benefited from more peer review.&lt;/li&gt;
  &lt;li&gt;Improvements from upstream ConsensusJ.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/#consensusj-namecoin&quot;&gt;Beta Downloads&lt;/a&gt; page.&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/21/consensusj-namecoin-v0.3.1-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/21/consensusj-namecoin-v0.3.1-released.html</guid>
        
        <category>Releases</category>
        
        <category>libdohj Releases</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC v3.2.2.2 Released</title>
        <description>&lt;p&gt;We’ve released Electrum-NMC v3.2.2.2.  Here’s what’s new:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fix exchange rate display.&lt;/li&gt;
  &lt;li&gt;Fix a few places where the UI still said “Bitcoin” instead of “Namecoin”.&lt;/li&gt;
  &lt;li&gt;Building for macOS might work now (no official macOS binaries yet, though).&lt;/li&gt;
  &lt;li&gt;Code quality improvements.&lt;/li&gt;
  &lt;li&gt;Build script fix from upstream Electrum.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/#electrum-nmc&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/13/electrum-nmc-v3.2.2.2-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/13/electrum-nmc-v3.2.2.2-released.html</guid>
        
        <category>Releases</category>
        
        <category>Electrum Releases</category>
        
        
      </item>
    
      <item>
        <title>ncdns v0.0.8 Released</title>
        <description>&lt;p&gt;We’ve released ncdns v0.0.8.  &lt;em&gt;But the previous release was v0.0.6, what happened to v0.0.7&lt;/em&gt;, you ask?  Well, since we’re a human rights project, we didn’t want to stain our release with a reference to the criminal organization that overthrew the democratically elected Iranian government, so v0.0.7 got skipped.  [1]  List of changes in v0.0.8:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TLS interoperability:
    &lt;ul&gt;
      &lt;li&gt;Firefox TLS certificate positive overrides via &lt;code class=&quot;highlighter-rouge&quot;&gt;cert_override.txt&lt;/code&gt; are now built into ncdns; manually running &lt;code class=&quot;highlighter-rouge&quot;&gt;ncdumpzone&lt;/code&gt; is no longer needed.  Some config file settings must be set manually for this to work.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DNS interoperability:
    &lt;ul&gt;
      &lt;li&gt;Fix support for DNAME records (AKA the Namecoin &lt;code class=&quot;highlighter-rouge&quot;&gt;translate&lt;/code&gt; field) in madns / ncdns.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tor interoperability:
    &lt;ul&gt;
      &lt;li&gt;Fix support for DNAME records (AKA the Namecoin &lt;code class=&quot;highlighter-rouge&quot;&gt;translate&lt;/code&gt; field) in &lt;code class=&quot;highlighter-rouge&quot;&gt;dns-prop279&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tools:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;generate_nmc_cert&lt;/code&gt;: Rebase against Go v1.8.3 standard library.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;generate_nmc_cert&lt;/code&gt;: Use P256 curve by default.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ncdumpzone&lt;/code&gt;: Use &lt;code class=&quot;highlighter-rouge&quot;&gt;easyconfig&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;kingpin&lt;/code&gt;; this allows config files to be used with &lt;code class=&quot;highlighter-rouge&quot;&gt;ncdumpzone&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Windows:
    &lt;ul&gt;
      &lt;li&gt;Upgrade dnssec-keygen to v9.13.2.&lt;/li&gt;
      &lt;li&gt;Upgrade DNSSEC-Trigger to v0.17.&lt;/li&gt;
      &lt;li&gt;Fix default &lt;code class=&quot;highlighter-rouge&quot;&gt;$APPDATA&lt;/code&gt; path for Namecoin Core.  This should fix a bug where Namecoin Core would crash with a permission error on 2nd run if Namecoin Core was installed for the first time via ncdns.&lt;/li&gt;
      &lt;li&gt;Disable cookie authentication when ConsensusJ-Namecoin is selected.  This should fix a bug where ncdns couldn’t connect to ConsensusJ-Namecoin.&lt;/li&gt;
      &lt;li&gt;Detect if Visual C++ 2010 Redistributable Package is missing.  This should fix a bug where ConsensusJ-Namecoin would crash on startup.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NetBSD:
    &lt;ul&gt;
      &lt;li&gt;NetBSD/ARM binaries are now available again.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Build system:
    &lt;ul&gt;
      &lt;li&gt;Upgrade Go to v1.10.3.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Miscellaneous:
    &lt;ul&gt;
      &lt;li&gt;Many code quality improvements.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/#ncdns&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;

&lt;p&gt;[1] Actually, I screwed up the release scripts and didn’t notice until after v0.0.7 was already tagged, so v0.0.7 was unreleaseable.  But I like the above reason better.&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/08/21/ncdns-v0.0.8-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/08/21/ncdns-v0.0.8-released.html</guid>
        
        <category>Releases</category>
        
        <category>ncdns Releases</category>
        
        
      </item>
    
  </channel>
</rss>
