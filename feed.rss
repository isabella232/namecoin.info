<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namecoin</title>
    <description><!--Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
--></description>
    <link>https://namecoin.org//</link>
    <atom:link href="https://namecoin.org//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 26 Oct 2018 01:06:37 +0000</pubDate>
    <lastBuildDate>Fri, 26 Oct 2018 01:06:37 +0000</lastBuildDate>
    <generator>Jekyll v3.6.0</generator>
    
      <item>
        <title>ElectrumX: Name Script Support Merged by Upstream</title>
        <description>&lt;p&gt;A few months ago I wrote about &lt;a href=&quot;/2018/07/15/electrumx-name-scripts.html&quot;&gt;name script support in ElectrumX&lt;/a&gt;.  Neil from ElectrumX has now merged that code into ElectrumX master branch.  I’ve also notified the operator of the public ElectrumX Namecoin instance, so hopefully soon it will be possible to use Electrum-NMC’s name script support with the default public ElectrumX instance.  Kudos to Neil for accepting the pull request!&lt;/p&gt;

&lt;p&gt;(This is probably a good time to remind readers that we need more ElectrumX instances… please consider running one if you have a server with spare resources!)&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/25/electrumx-name-scripts-merged.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/25/electrumx-name-scripts-merged.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: Name Registration GUI</title>
        <description>&lt;p&gt;Now that &lt;a href=&quot;/2018/10/09/electrum-nmc-name-update-gui.html&quot;&gt;Electrum-NMC GUI support for updating names&lt;/a&gt; is a thing, it’s time to advance to name registration GUI support.&lt;/p&gt;

&lt;p&gt;Whereas the &lt;code class=&quot;highlighter-rouge&quot;&gt;Renew Name&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure Name...&lt;/code&gt; buttons each map directly to a single sequence of two console commands (&lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt;), which makes their implementation relatively straightforward, &lt;em&gt;registering&lt;/em&gt; a name is more complicated, due to the two-step procedure in which a salted commitment (&lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt;) is broadcast 12 blocks before the name registration itself (&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt;) in order to prevent frontrunning attacks.  Given that the name registration procedure was going to be a bit complicated, it seemed like a good idea to create a new console command for this purpose, so that the GUI can maintain a simple mapping to console commands.&lt;/p&gt;

&lt;p&gt;In fact, I ended up creating a few different console commands.  The first console command (&lt;code class=&quot;highlighter-rouge&quot;&gt;queuetransaction&lt;/code&gt;) is used for storing transactions in the wallet that are intended to be broadcasted in the future once a trigger condition has occurred.  An entry in the transaction queue consists of:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Either a transaction ID or a name identifier&lt;/li&gt;
  &lt;li&gt;A depth (in blocks)&lt;/li&gt;
  &lt;li&gt;A raw transaction&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When the specified transaction ID (or the most recent transaction for the specified name identifier) attains sufficient confirmations in the blockchain, the raw transaction will be broadcasted.  In order to register a name, the following transaction queue entry would be used:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Transaction ID of &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Depth of 12 blocks&lt;/li&gt;
  &lt;li&gt;Raw transaction of &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are some other use cases for the transaction queue, such as automatically renewing names when they’re approaching expiration, or automatically registering a name if/when its previous owner lets them expire.  For now, we’ll focus on name registration.&lt;/p&gt;

&lt;p&gt;Next up was a console command &lt;code class=&quot;highlighter-rouge&quot;&gt;updatequeuedtransactions&lt;/code&gt;, which examines each of the transaction queue entries, and broadcasts and unqueues each of the entries whose trigger condition has been achieved.  This wasn’t too complicated, although I did do some deliberating on when exactly to unqueue a transaction.  In theory, an ElectrumX server could claim to have broadcasted a transaction but not actually do so, and if Electrum-NMC unqueues a transaction in this case, then the transaction will never actually get mined.  A sledgehammer-style workaround here would be to try to re-broadcast each block until Electrum-NMC sees an SPV proof indicating that the transaction has, say, 12 confirmations (indicating that it very likely did get broadcasted and mined).  However, I ended up deciding that this kind of attack is simply out of scope for the transaction queue, since the attack can apply equally well to arbitrary other transactions that get broadcasted.  Solving this attack is probably something better done in upstream Electrum than by whatever hacky and poorly peer-reviewed approach we’d take in Electrum-NMC.  So, we unqueue the transaction as soon as it’s broadcast.  Easy enough.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;updatequeuedtransactions&lt;/code&gt; is cool, but we want this to happen every block, automatically.  So the next step was to add a hook that calls &lt;code class=&quot;highlighter-rouge&quot;&gt;updatequeuedtransactions&lt;/code&gt; whenever a new block arrives.  This should have been simple, but I quickly noticed that whenever this hook resulted in broadcasting a transaction, an assertion error would get logged, and the transaction would never broadcast.  A quick inspection showed that the &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt; console command should never be called from the network thread, and the hook was indeed being called from the network thread (where the incoming block event came from).  After a little bit of tinkering, I determined that the simplest approach was just to re-emit the incoming block event to the GUI thread, and then call &lt;code class=&quot;highlighter-rouge&quot;&gt;updatequeuedtransactions&lt;/code&gt; from the GUI thread’s event.&lt;/p&gt;

&lt;p&gt;Okay, so the groundwork is laid, now to actually implement a console command for name registration.  In theory, this should be easy: it should consist of &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;queuetransaction&lt;/code&gt;, right?  Actually, things are a lot more complicated, because if any of the currency inputs to the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transaction get spent in the 12-block interval before it gets broadcasted, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; will be rejected as a double-spend.  Hypothetically, I could have fixed this by abusing the address-freezing functionality of Electrum, but there’s a better way: pure name transactions.&lt;/p&gt;

&lt;p&gt;Pure name transactions are a highly interesting form of Namecoin transaction, where currency is embedded inside a name instead of being kept in a separate input/output.  This works because the 0.01 NMC cost of registering a name is actually enforced as a &lt;em&gt;minimum&lt;/em&gt; amount of a name output, not an &lt;em&gt;exact&lt;/em&gt; amount.  You can put, for example, 0.03 NMC into a name output, and you can later withdraw the excess 0.02 NMC by spending that name output.  As long as the amount never drops below the 0.01 NMC minimum, the Namecoin consensus rules don’t care.  There are two major use cases for pure name transactions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Reducing transaction size.  Obviously, 1 input and 1 output will yield a smaller transaction than 2 inputs and 2 outputs, which reduces blockchain bloat and transaction fees.  (As far as I know, this use case was first described in a discussion at ICANN58 about Namecoin scalability.)&lt;/li&gt;
  &lt;li&gt;Keeping coins organized.  If you’ve ever tried to renew more than 25 names in Namecoin Core at once, you might have noticed that you got an error about a long chain of unconfirmed transactions.  This happens because each renewal uses a currency input that’s the currency output of the previous renewal, forming a long chain of transactions.  The Namecoin Core error happens because Namecoin Core considers it risky to have a chain of more than 25 unconfirmed transactions (if the first one never got confirmed, all the others would be stuck too).  However, with pure name transactions, each name has its own currency coins, which are temporarily earmarked for use with that name, so operations with different names can’t interfere with each other.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The latter use case is what we’ll use here.  We create a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction with no currency outputs, but whose name output has an extra 0.005 NMC attached to it.  When we create the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transaction, we instruct Electrum-NMC’s coin selection algorithm to only use the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; input, and to pay any fees out of the extra 0.005 NMC.  (Coincidentally, I’m pretty sure that Mikhail’s Namecoin-Qt client, from the era before Namecoin Core, did the same thing.)  As a result, we can be confident that no accidental double-spends will occur, because we definitely won’t be spending the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; output before we broadcast the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transaction.  Interestingly, making this work actually needed some minor changes to the Electrum-NMC coin selection algorithm, because parts of the coin selector are not designed to work properly with zero currency inputs being selected.  (Which is understandable, since such a transaction would never be possible in Bitcoin.)&lt;/p&gt;

&lt;p&gt;With that, we have a single console command, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_autoregister&lt;/code&gt;, which does what we want, so now it’s time to create a GUI for it.  This was relatively uneventful, but it’s notable that I decided to have a separate &lt;code class=&quot;highlighter-rouge&quot;&gt;Buy Names&lt;/code&gt; tab instead of putting the registration widgets on the existing &lt;code class=&quot;highlighter-rouge&quot;&gt;Manage Names&lt;/code&gt; tab.  The reasoning for this is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;Buy Names&lt;/code&gt; tab is a convenient place to show other widgets that don’t exist yet, such as giving you the opportunity to atomically trade NMC for a name if the name you want is already registered.&lt;/p&gt;

&lt;p&gt;And now, here’s your regular fix of screenshots:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-17-Buy-Name-Entry.png&quot; alt=&quot;A screenshot of entering a name on the Electrum-NMC Buy Names tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-17-Buy-Name-Available.png&quot; alt=&quot;A screenshot of a name available for registration on the Electrum-NMC Buy Names tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-17-Buy-Name-Taken.png&quot; alt=&quot;A screenshot of a name already taken on the Electrum-NMC Buy Names tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/21/electrum-nmc-name-registration-gui.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/21/electrum-nmc-name-registration-gui.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>NSS certutil Windows/macOS rbm Build Scripts Merged by The Tor Project</title>
        <description>&lt;p&gt;As I mentioned earlier, &lt;a href=&quot;/2018/09/27/certutil-windows-rbm-submitted-tor-project.html&quot;&gt;I submitted some patches&lt;/a&gt; to The Tor Project for building NSS certutil binaries for Windows and macOS as part of Tor Browser’s rbm build scripts.  I’m happy to report that after a (quite well-justified) delay, and after some (quite reasonable) mild edits were requested and made, the Tor developers have merged my patches.&lt;/p&gt;

&lt;p&gt;This has benefits to multiple parties.  It benefits Namecoin since it means we get trustworthy certutil binaries for our Namecoin TLS releases [1].  It benefits the broader NSS ecosystem on Windows and macOS, since (among other things) it means that Firefox users on Windows and macOS won’t need to download random binaries linked from StackExchange or forums, or self-compile NSS, just in order to add certificates to their trust store from the command line.  (Based on the number of such forum threads I found via a cursory web search, there are a lot of such users.)  It benefits Tor, since it means that users who wouldn’t otherwise be interacting with the Tor ecosystem will now have a reason to do so, which gives Tor some free publicity.  And it benefits the reproducible build ecosystem, because many users who previously assumed they’d either have to risk downloading malware or build from source will now be learning about the benefits of reproducible builds for the first time (and will hopefully start demanding similar security guarantees from the developers of other software they use).&lt;/p&gt;

&lt;p&gt;This is why, at Namecoin, we try to get our work upstreamed as much as possible – we aim for maximum public benefit across the ecosystem, rather than maintaining forks of software for our own limited use cases.  Kudos to the Tor devs for the excellent code review experience.  I’m looking forward to getting more patches upstreamed to Tor in the future.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;

&lt;p&gt;[1] Of course, this is partially negated by the fact that some ongoing R&amp;amp;D happening at Namecoin suggests that we may be able to ditch the certutil dependency, in favor of some other approaches with less attack surface.  But I’ll save that for another post.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/15/certutil-rbm-merged-tor-project.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/15/certutil-rbm-merged-tor-project.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: Name Update GUI</title>
        <description>&lt;p&gt;I previously wrote about &lt;a href=&quot;/2018/10/06/electrum-nmc-name-transaction-creation.html&quot;&gt;creating name transactions in the Electrum-NMC console&lt;/a&gt;.  Next up, adding GUI support.&lt;/p&gt;

&lt;p&gt;The new &lt;code class=&quot;highlighter-rouge&quot;&gt;Renew Name&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure Name...&lt;/code&gt; buttons use the previously discussed &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; command as their backend, which makes implementation relatively simple, since it’s not difficult for GUI functions to access console commands.  I facilitated the &lt;code class=&quot;highlighter-rouge&quot;&gt;Renew Name&lt;/code&gt; command by making the &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; parameter of &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; optional; if not supplied, it will be set to the current value of the name.&lt;/p&gt;

&lt;p&gt;However, this introduces an interesting attack scenario: if an ElectrumX server falsely reports the current value of a name you own and you click the Renew button, you would be tricked into signing a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; transaction that contains the malicious value.  Therefore, to mitigate this scenario, &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; is only optional if the latest transaction for the name has at least 12 confirmations.  I can’t picture any way that this mitigation would cause real-world UX problems; presumably no one wants to renew a name that was already last updated fewer than 12 blocks ago.&lt;/p&gt;

&lt;p&gt;One nice UX improvement in Electrum-NMC compared to Namecoin-Qt is that you can renew multiple names at once: just select more than one name in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Manage Names&lt;/code&gt; tab, and then click &lt;code class=&quot;highlighter-rouge&quot;&gt;Renew Name&lt;/code&gt;.  Implementing this was a bit tricky, because Electrum’s coin selection algorithm doesn’t normally notice that a coin has been spent until it receives a copy from the ElectrumX server, which is usually a few seconds after we broadcast it to the ElectrumX server.  As a result, the coin selection algorithm would try to double-spend the same currency input for each name renewal.  I fixed this by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;addtransaction(tx)&lt;/code&gt; (which adds a transaction to the wallet) immediately after &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast(tx)&lt;/code&gt; returns success, before moving on to the the next name to renew.&lt;/p&gt;

&lt;p&gt;It should be noted that renewing multiple names at once will probably reveal to blockchain deanonymizers that the affected names have common ownership.  So, while this feature is potentially useful, it should be used with care.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure Name...&lt;/code&gt; button and associated dialog were relatively uneventful in terms of bugs.  That said, it did occur to me that it might be better to re-use Namecoin-Qt’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.ui&lt;/code&gt; form files for this purpose instead of re-implementing the dialog in Python.  Unfortunately, Namecoin-Qt’s form files are a bit too specific to Bitcoin Core (e.g. they incorporate widgets that only exist in Bitcoin Core, which have different implementations in Electrum).  I think it would be plausible to improve the abstraction of Namecoin-Qt’s form files so that we could re-use them in Electrum-NMC and save on duplicated GUI effort; hopefully something will happen there after higher-priority tasks are dealt with in the Namecoin-Qt codebase.&lt;/p&gt;

&lt;p&gt;And now, screenshots!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-06-Manage-Names-Tab.png&quot; alt=&quot;A screenshot of the &amp;quot;Renew Name&amp;quot; and &amp;quot;Configure Name...&amp;quot; buttons visible in the Electrum-NMC Manage Names tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-06-Configure-Name-Dialog.png&quot; alt=&quot;A screenshot of the &amp;quot;Configure Name&amp;quot; dialog in Electrum-NMC.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/09/electrum-nmc-name-update-gui.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/09/electrum-nmc-name-update-gui.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: Name Transaction Creation</title>
        <description>&lt;p&gt;In a previous article, I wrote about &lt;a href=&quot;/2018/10/04/electrum-nmc-name-script-deserialization-round-2.html&quot;&gt;the “reading” side of Electrum-NMC’s name script support&lt;/a&gt; (i.e. detecting and displaying name transactions in the wallet, and doing name lookups).  Obviously, the logical next step is the “writing” side, i.e. creating name transactions.&lt;/p&gt;

&lt;p&gt;I started out by trying to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt;.  Electrum’s command API is quite flexible (yet quite user-friendly), so most of the relevant functionality was fairly straightforward to implement by adding slight modifications to the existing transaction creation commands.  These modifications essentially just add an extra output to the transaction that has a non-null name operation.  I did, however, need to add some extra functionality to the accounting, to adjust for the fact that a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction destroys 0.01 NMC by permanently locking it inside an output.  (Usually, it’s desirable to treat that locked namecent as zero for display purposes, but when funding a transaction, treating it as zero would produce Bad Things ™.)&lt;/p&gt;

&lt;p&gt;Electrum’s API philosophy differs from that of Bitcoin Core, in that while Bitcoin Core wallet commands tend to broadcast the result automatically, Electrum wallet commands tend to simply return a transaction, which you’re expected to broadcast with the &lt;code class=&quot;highlighter-rouge&quot;&gt;broadcast&lt;/code&gt; command.  I’m following this approach for the name wallet commands.  Creating the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction completed rather easily without errors; however, when I tried to broadcast the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction, it was rejected by my Namecoin Core node that serves as the backend for my ElectrumX instance.  I inspected my Namecoin Core node’s &lt;code class=&quot;highlighter-rouge&quot;&gt;debug.log&lt;/code&gt;, and quickly found the issue: I had forgotten to set the transaction’s &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; field to the value that permits name operations.  Namecoin requires all name operations to appear in transactions with an &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; field of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7100&lt;/code&gt;, which is a value that doesn’t show up in Bitcoin at all.  I decided not to modify the transaction construction API’s in Electrum to allow manual setting of the &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; field per command (end users don’t want to think about these details), and instead decided that it was easier to simply add a couple of lines to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Transaction&lt;/code&gt; class so that if you supply it with an output that has a name operation attached to it, the resulting transaction will automatically have its &lt;code class=&quot;highlighter-rouge&quot;&gt;nVersion&lt;/code&gt; modified.&lt;/p&gt;

&lt;p&gt;With that fix, I could create &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions and broadcast them.  I sent a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; from Electrum-NMC to my Namecoin Core wallet and also created one that stayed within Electrum-NMC.  The underlying logic here was two-fold: (1) I wanted to make sure that both explicitly-specified recipient addresses and automatically-generated local addresses worked properly, and (2) if an issue happened while trying to spend the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; outputs with Electrum-NMC, I wanted to be able to quickly compare the results with Namecoin Core so that I would know whether the problem was with the code trying to spend the output or with the code that created the output.&lt;/p&gt;

&lt;p&gt;While both &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions were reaching their required 12 blocks of confirmations, I implemented &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; support.  This was a little bit more interesting, because it meant I had to explicitly add a mandatory name &lt;strong&gt;input&lt;/strong&gt; (the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt;) in addition to a mandatory name &lt;strong&gt;output&lt;/strong&gt; (the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt;).  Electrum makes it very easy to add mandatory outputs, since that’s commonplace in Bitcoinland.  Adding mandatory inputs, however, is not exactly straightforward.  I ended up modifying a few of the coin selection algorithms to allow specifying mandatory inputs that would be applied before any other inputs are added, and while I wish it could be done with fewer changes, I’m reasonably happy with the result.&lt;/p&gt;

&lt;p&gt;Creating the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transaction was relatively easy to do from Electrum-NMC without errors.  Unfortunately, once again the transaction was rejected by my ElectrumX instance’s Namecoin Core node.  This time the error was a lot less intelligible; the error had something to do with the signature check failing, but it wasn’t clear to me exactly what the problem was.  To narrow down the issue, I tried spending the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; that I had sent to my Namecoin Core wallet into a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt;, and that one worked fine.  So clearly the issue was in the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; code in Electrum-NMC, and not anything broken in the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; that was already created.  I ended up copying the invalid transaction into Namecoin Core’s &lt;code class=&quot;highlighter-rouge&quot;&gt;decoderawtransaction&lt;/code&gt; RPC method, and then pasting the hex-encoded script into &lt;a href=&quot;https://siminchen.github.io/bitcoinIDE/build/editor.html&quot;&gt;Bitcoin IDE&lt;/a&gt; to simulate exactly what was happening.  And it definitely was clear that something was wrong: the hash that the signature signed didn’t match the hash it was supposed to be signing.&lt;/p&gt;

&lt;p&gt;This seemed rather weird, since I hadn’t touched any of the signature code.  After some grep-fu of the Electrum codebase, I figured out what had happened.  In Bitcoin transactions, the signatures cover the scriptPubKeys of the previous transaction outputs.  This shouldn’t be a problem, but Electrum tries to be clever in order to avoid actually looking up the previous transactions.  Electrum actually guesses the previous scriptPubKey based on the scriptSig.  This actually works fine for the transaction types that one normally finds in Bitcoinland.  However, in Namecoin, name operations are prefixed to the scriptPubKey, and nothing about that name prefix (even whether one exists at all) can be inferred from the scriptSig that spends the name output.  As a result, the previous scriptPubKey that was being signed didn’t have a name prefix at all, which of course caused the hashes to mismatch.&lt;/p&gt;

&lt;p&gt;Modifying the wallet code to pass through name operations to the data structures that the scriptPubKey-guessing code has access to wasn’t particularly painful, nor was modifying the scriptPubKey-guessing code to prefix the correct name script when needed.  With that out of the way, a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; from Electrum-NMC was able to broadcast successfully.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; was comparatively simple.  The main change needed for this one was that while &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; specified the mandatory name input by TXID, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; specifies it by name identifier.  Adding this functionality to the coin selection algorithms wasn’t particularly unpleasant.  And thus, I was able to create and broadcast a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; transaction as well.  Yay!&lt;/p&gt;

&lt;p&gt;The next future step is probably to hook these commands into the GUI.&lt;/p&gt;

&lt;p&gt;And, with that out of the way, here are some transactions I created with Electrum-NMC’s console:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/9204de3739850d6e0c9c8a5a838747485c1dabddc319a8abfc83f004694e3723&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; created by Electrum-NMC, sent to Namecoin Core&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/804631725e80ff334fecb8fba85ddbb76ede99ba36d951dac5ab41cb462a375f&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; created by Namecoin Core, spending the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; created by Electrum-NMC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/317c6391c94a14c0d777b56b6b31ff1124ce8a6c98874a447239a654f605018a&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; created by Electrum-NMC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/tx/978122fd205d2f87b333b433af51b2e0f9b67ed9b6270d2fa2cbb013e30c0ffd&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; created by Electrum-NMC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/06/electrum-nmc-name-transaction-creation.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/06/electrum-nmc-name-transaction-creation.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Halving Day (Block 420000)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://namecoin.cyphrs.com/block/420000&quot;&gt;Block number 420000&lt;/a&gt; (hash &lt;code class=&quot;highlighter-rouge&quot;&gt;145f72ea59018ca4117015e3c25a2ed24e22e67c948841dd46a200db11d778be&lt;/code&gt;) was mined at &lt;code class=&quot;highlighter-rouge&quot;&gt;2018-10-04 01:10:19 +0000&lt;/code&gt; by Slush Pool with a block reward of 12.5 NMC plus fees.  From all of us at Namecoin, Happy Halving Day, everyone!&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Oct 2018 02:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/04/halving-day.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/04/halving-day.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: Name Script Deserialization (Round 2: Name History Display, Name Lookups, and Manage Names Tab)</title>
        <description>&lt;p&gt;I previously wrote about some work on &lt;a href=&quot;/2018/08/06/electrum-nmc-name-script-deserialization.html&quot;&gt;making Electrum-NMC handle name scripts&lt;/a&gt;.  In the last few days I hacked on that code some more.&lt;/p&gt;

&lt;p&gt;As you may have noticed from the screenshot in the previous article, I’m initially testing this code with watching-only wallets, since there are fewer moving parts there and I don’t have to worry about constructing and signing transactions.  When looking for addresses to add to the watching-only wallet, I usually just look through the &lt;a href=&quot;https://namecoin.cyphrs.com/&quot;&gt;Cyphrs block explorer&lt;/a&gt; and take the first few name transactions that show up of each desired type.  Interestingly, I noticed that a subset of the name transactions I picked from the explorer this time weren’t visible in the Electrum-NMC GUI.  Some querying of my ElectrumX server indicated that the transactions were definitely being delivered to Electrum-NMC, and inspecting Electrum-NMC’s wallet file showed that the transactions were definitely being added to the wallet.  But for some reason, Electrum-NMC wasn’t displaying them.&lt;/p&gt;

&lt;p&gt;After quite a lot of tracing through the code, I figured out that the transactions in question had name scripts that weren’t successfully being recognized as name scripts.  Some more tracing led me to figure out that the code was failing to parse any &lt;code class=&quot;highlighter-rouge&quot;&gt;name_anyupdate&lt;/code&gt; script whose value was the empty string.  Turns out that upstream Electrum has a wildcard-like script matching function that can detect arbitrary data pushes (which I was using) – but for some reason they don’t treat &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_0&lt;/code&gt; as a data push for the purpose of that wildcard matching.  Pushing the empty string to the stack is implemented by… you guessed it, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_0&lt;/code&gt;.  I filed a GitHub issue with upstream Electrum about this, and it looks like they’ve fixed it upstream (quite quickly, too).  While I was waiting for them to fix it, I did implement a (very hacky) workaround in Electrum-NMC’s name script parser, but that workaround will most likely be removed (yay!) when I next merge from upstream Electrum.  Kudos to the upstream Electrum devs on this; they’ve consistently been quite helpful (and quick) at implementing fixes that make life easier for downstream projects like Electrum-NMC.&lt;/p&gt;

&lt;p&gt;I had previously implemented some special UI code for displaying that a name transaction is a transfer operation.  This is a UX improvement over Namecoin Core, which confusingly displays both incoming and outgoing name transfers identically to name updates.  I had defined a name transfer as “a name transaction for which the wallet owns a name input XOR the wallet owns a name output”.  Do you see a problem here?  Yeah, that definition matches &lt;strong&gt;all&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions where the wallet owns the output, because &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transactions &lt;em&gt;don’t have a name input&lt;/em&gt;.  D’oh.  Fixed that.&lt;/p&gt;

&lt;p&gt;Up next was displaying the name identifiers in the UI.  Again, I’m trying to improve on Namecoin Core’s UX here.  For example, I prefer to make &lt;code class=&quot;highlighter-rouge&quot;&gt;d/wikileaks&lt;/code&gt; show up as &lt;code class=&quot;highlighter-rouge&quot;&gt;wikileaks.bit&lt;/code&gt;.  My code also recognizes invalid &lt;code class=&quot;highlighter-rouge&quot;&gt;d/&lt;/code&gt; names, e.g. names with uppercase characters, and indicates that they’re not valid domain names.  Ditto for &lt;code class=&quot;highlighter-rouge&quot;&gt;id/&lt;/code&gt; names.  In addition, if the namespace is unknown or the identifier isn’t valid under the namespace rules, I actually check whether the identifier consists entirely of ASCII printable characters.  If it does, I print it in ASCII; if it doesn’t, I print it in hex.  Similar checks are in place for values.  The Namecoin consensus rules have always allowed binary data to exist in identifiers and values, but the UI for this functionality was pretty much always missing.  Electrum-NMC should handle this kind of thing without trouble.  One practical example of how this could be used in the future is storing values as CBOR rather than JSON.  CBOR is substantially more compact, especially when encoding binary data like TLS certificates, which means &lt;em&gt;moar scaling&lt;/em&gt; and &lt;em&gt;moar savings on transaction fees&lt;/em&gt;.  (CBOR also seems to be a common choice by the DNS community, including people at IETF and ICANN.)&lt;/p&gt;

&lt;p&gt;Then, I implemented the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; console command.  For readers unfamiliar with the Namecoin Core RPC API, &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; is the command that &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; resolvers like ncdns use to look up name data from Namecoin Core and ConsensusJ-Namecoin.  My &lt;code class=&quot;highlighter-rouge&quot;&gt;name_show&lt;/code&gt; implementation in Electrum-NMC includes SPV verification, just like Electrum’s history tab.  Every output JSON field from Namecoin Core is present, although currently none of the optional input fields are supported.  It probably wouldn’t be very difficult to hook this into ncdns.  However, it should be noted that Electrum’s SPV verification is a weaker security model than ConsensusJ-Namecoin’s leveldbtxcache SPV security model.  In addition, there’s only one public Namecoin ElectrumX server instance, so the concept of the “chain with most work” isn’t exactly meaningful.  Even so, it’s vastly more secure than centralized inproxies like OpenNIC, and it might be useful for some people.  Hopefully more people will step up to run public Namecoin ElectrumX servers so that the SPV security model can actually work as intended.&lt;/p&gt;

&lt;p&gt;Finally, I implemented a first pass at the Manage Names tab.  Display of the name identifier, value, and expiration block count are working.  This was a lot easier than implementing from scratch would be, because the Manage Names tab (referred to in the code as the UNO List widget) is actually just a subclass of the Coins tab (referred to in the code as the UTXO List widget).&lt;/p&gt;

&lt;p&gt;So, with that explanation out of the way, here’s what you really came here for: &lt;em&gt;screenshots!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-09-29-Names-in-History-Tab.png&quot; alt=&quot;A screenshot of name transactions visible in the Electrum-NMC History tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-09-29-Name-in-Transaction-Details.png&quot; alt=&quot;A screenshot of name data visible in the Electrum-NMC Transaction Details tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-09-29-Name-Show-in-Console-Tab.png&quot; alt=&quot;A screenshot of a name_show command's output in the Electrum-NMC Console tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-10-01-Manage-Names-Tab.png&quot; alt=&quot;A screenshot of the Electrum-NMC Manage Names tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs and NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/10/04/electrum-nmc-name-script-deserialization-round-2.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/10/04/electrum-nmc-name-script-deserialization-round-2.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>NSS certutil Windows rbm Build Scripts Submitted Upstream to The Tor Project</title>
        <description>&lt;p&gt;Previously, I covered &lt;a href=&quot;/2018/05/17/reproducible-builds-certutil-cross-compiling-rbm.html&quot;&gt;cross-compiling NSS certutil for Windows&lt;/a&gt; via Tor’s rbm build scripts.  Since I like to be a good neighbor, I’ve since reached out to the very nice people at Tor, and have submitted a patch to get this merged upstream.  I’ve already received a Concept ACK, although they cautioned me that they’re quite busy with other Tor Browser things at the moment and it may take a while for them to review my patch.  The Tor people requested that I consider adding macOS support as well; I’ve done so and that patch is also submitted to Tor for review.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/27/certutil-windows-rbm-submitted-tor-project.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/27/certutil-windows-rbm-submitted-tor-project.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>How Centralized Inproxies Make Everyone Less Safe (A Case Study)</title>
        <description>&lt;p&gt;Readers who have followed Namecoin for a while know that I’ve been sharply critical of centralized inproxies since I joined Namecoin development in 2013.  For readers who are unfamiliar with the concept, a centralized inproxy is a piece of infrastructure (run by a trusted third party) that allows users who aren’t part of a P2P network to access resources that are hosted inside that P2P network.  You can think of it as analogous to a web wallet in the Bitcoin world, except that whereas web wallets are for people who &lt;em&gt;own&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; websites, centralized inproxies are for people who &lt;em&gt;view&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; websites.  Centralized inproxies introduce security problems that are likely to be obvious to anyone familiar with the history of Bitcoin web wallets (I’m among the people who were around when &lt;em&gt;MyBitcoin&lt;/em&gt; existed but refused to use it; we were proven right when &lt;em&gt;MyBitcoin&lt;/em&gt; exit-scammed).&lt;/p&gt;

&lt;p&gt;However, for reasons that elude me, the concept of centralized inproxies seems to have an irritatingly persistent set of proponents.  It’s rare that a month goes by without having some rando on the Internet ask us to endorse, collaborate with, or develop a centralized inproxy (it’s only the 18th of this month as I write the first draft of this article, and it’s already happened twice this month).  I’ve personally been accused of trying to kill Namecoin via stagnation because I don’t support centralized inproxies.  The degree to which the advocacy for centralized inproxies is actually organic is dubious at best (there is evidence that at least one particularly loud and aggressive proponent of the concept has been motivated by undisclosed financial incentives).  However, regardless of how inorganic it may be, we encounter the request often enough that we actually added an entry to our FAQ about why we don’t support centralized inproxies.  In this post, I’d like to draw attention to the “Security concerns” section of that FAQ entry, specifically the 3rd bullet point:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;ISP’s would be in a position to censor names without easy detection.&lt;/li&gt;
    &lt;li&gt;ISP’s would be in a position to serve fraudulent PKI data (e.g. TLSA records), which would enable ISP’s to easily wiretap users and infect users with malware.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Either of the above security concerns would even endanger users who are running Namecoin locally, because it would make it much more difficult to detect misconfigured systems that are accidentally leaking Namecoin queries to the ISP.&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;The 3rd bullet point is intended as a debunking of the disturbingly common claim that “The security drawbacks only affect users who have opted into the centralized inproxy, and we would encourage users who care about security to install Namecoin locally.”  Even though I’ve been citing this concern for years, I had mostly been citing it in the sense of “This is going to burn someone eventually if centralized inproxies become widespread”; I hadn’t been citing it in the sense of “I personally have seen this happen in the wild.”&lt;/p&gt;

&lt;p&gt;Which brings us to a case study that I accidentally initiated recently.&lt;/p&gt;

&lt;p&gt;I was recently setting up a VM for Namecoin-related testing purposes.  In particular, this VM was to be used for some search-engine-related research (those of you who saw my science fair exhibit at the 2018 Decentralized Web Summit will be able to guess what I was doing).  I have a relatively standard procedure for setting up Namecoin VM’s, but admittedly I don’t do it very often.  I was particularly rusty in this case because I usually set up a Namecoin VM in Qubes/Xen, while this time I was using Debian/KVM (this is because my search engine needed a lot of RAM, meaning it was running on my Talos, and Qubes/Xen doesn’t run on the Talos yet).  Somehow, I managed to goof up the setup of the VM, and Namecoin resolution wasn’t actually running on it when I thought it was.  However, at the time I didn’t know this; it definitely looked like Namecoin was working.  I proceeded to do my search engine testing, and eventually (after about 30 minutes of clicking &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; links continuously) I noticed something odd.  I had clicked on a &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; link that I recalled (from previous testing many months prior) was misconfigured by the name owner, and therefore didn’t work in standards-compliant Namecoin implementations – but the name in question &lt;em&gt;did&lt;/em&gt; work in buggy inproxies like OpenNIC.  And, lo and behold, the link loaded without any errors in my VM.  My initial impression was to figure that maybe the name owner finally got around to fixing their broken name.  But I was curious to see when the change had been made, so I checked the name in the Cyphrs block explorer to see the transaction history of the name.  Hmm, that’s odd, no such fix ever was deployed.&lt;/p&gt;

&lt;p&gt;At this point, I was suspicious, so I started testing my network configuration.  And I discovered, to my surprise, that my &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; DNS traffic wasn’t being routed through ncdns and Namecoin Core – a network sysadmin upstream of my machine’s network connection had set their DNS to use OpenNIC’s resolver, and my &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; DNS traffic was being resolved by OpenNIC.&lt;/p&gt;

&lt;p&gt;Let’s look at some mitigating factors that helped me notice as quickly as I did:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I was visiting a wide variety of &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; sites from that VM; most users won’t be visiting many &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; sites.&lt;/li&gt;
  &lt;li&gt;I already had memorized a few &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains that had a broken configuration, and already knew that OpenNIC had incorrect handling of that broken configuration; most users have no idea how to identify a broken domain name configuration on sight (and certainly won’t have memorized a set of domains that have such configurations), and won’t have any knowledge of whatever obscure standards-compliance quirks exist in specific inproxy implementations.&lt;/li&gt;
  &lt;li&gt;I knew how to use a block explorer as a debugging tool; most users of Namecoin don’t use block explorers, just like most users of the DNS don’t use DNS “looking glass” tools.&lt;/li&gt;
  &lt;li&gt;I was able to walk down the hall to check with the network sysadmin, and knew exactly what question to ask him: “Is your network using OpenNIC’s DNS resolvers?”  Most users have never heard of OpenNIC, nor would they have any idea to ask such a question, nor would they necessarily be able to easily contact their network sysadmin, nor would they necessarily have a network sysadmin who would know the answer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Despite these substantial mitigating factors, it took me at least a half hour to notice.  That’s half an hour of web traffic that was trivially vulnerable to censorship and hijacking.  Would a typical user notice this kind of misconfiguration within a month?  I’m skeptical that they would.&lt;/p&gt;

&lt;p&gt;Now consider the threat models that a significant portion of the Internet’s users deal with.  For many Internet users (e.g. activists and dissidents), having the government be able to censor and hijack their traffic for a month without detection can easily lead to kidnapping, torture, and death.  There is a strong reason why the &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt; suTLD designation requires that DNS infrastructure (in particular, the ICANN root servers) return &lt;code class=&quot;highlighter-rouge&quot;&gt;NXDOMAIN&lt;/code&gt; for all &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt; domain names, rather than permitting ICANN or DNS infrastructure operators to run inproxies for &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt;.  That reason is that it is important for users of misconfigured systems to quickly notice that something is broken, rather than to have the system silently fall back to an insecure behavior that still looks on the surface like it works.  IETF and ICANN are doing exactly the right thing by making sure that &lt;code class=&quot;highlighter-rouge&quot;&gt;.onion&lt;/code&gt; stays secure so that at-risk users don’t get murdered.  The draft spec for adding &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; as a suTLD (along with I2P’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.i2p&lt;/code&gt; and GNUnet’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.gnu&lt;/code&gt;) made the same guarantees (and ICANN is currently doing the right thing for &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; by not having allocated it as a DNS TLD).&lt;/p&gt;

&lt;p&gt;For me, the experience of accidentally using a centralized inproxy was primarily a waste of under an hour of my time, and a bit of embarrassment.  (Also, my network sysadmin promptly dropped OpenNIC from his configuration when I told him of the incident.)  But I hope that the community can take this as a learning opportunity, to better appreciate the inevitability of something catastrophic eventually happening if centralized inproxies are allowed to proliferate.  Let’s not be the project that ends up getting one of our users killed as collateral damage in a quest for rapidly-deployed ease-of-use.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/24/how-centralized-inproxies-make-everyone-less-safe-case-study.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/24/how-centralized-inproxies-make-everyone-less-safe-case-study.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin Core 0.16.3 Released</title>
        <description>&lt;p&gt;Namecoin Core 0.16.3 has been released on the &lt;a href=&quot;/download/#namecoin-core-client-stable-release&quot;&gt;Downloads page&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/09/22/namecoin-core-0.16.3-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/09/22/namecoin-core-0.16.3-released.html</guid>
        
        <category>Releases</category>
        
        <category>Namecoin Core Releases</category>
        
        
      </item>
    
  </channel>
</rss>
