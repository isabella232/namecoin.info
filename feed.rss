<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namecoin</title>
    <description><!--Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
--></description>
    <link>https://namecoin.org//</link>
    <atom:link href="https://namecoin.org//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 15 Aug 2018 03:08:18 +0000</pubDate>
    <lastBuildDate>Wed, 15 Aug 2018 03:08:18 +0000</lastBuildDate>
    <generator>Jekyll v3.6.0</generator>
    
      <item>
        <title>ncdns NSIS Installer UX: Detection of Visual C++ 2010 Redistributable Package</title>
        <description>&lt;p&gt;If you’ve used ConsensusJ-Namecoin (our lightweight SPV name lookup client), you’ve probably noticed that we instruct users (on the Download page) to install the Microsoft Visual C++ 2010 Redistributable Package.  Failing to do this will result in the LevelDB library failing to load, which ends up causing some incredibly misleading error messages, after which &lt;code class=&quot;highlighter-rouge&quot;&gt;namecoinj-daemon&lt;/code&gt; will terminate.  Unfortunately, in the Real World™, users don’t reliably follow instructions.  (Confession: I’ve failed to follow this instruction when setting up test VM’s before, and took quite a while to figure out what was broken.)&lt;/p&gt;

&lt;p&gt;But how to improve the UX here?  Distributing the relevant package is legally questionable, so we can’t do that.  However, an alternative is to make the ncdns NSIS installer (which handles user-friendly installation on Windows) detect whether the package is already installed, and display a more user-friendly error during installation so that users know what’s wrong and how to fix it.&lt;/p&gt;

&lt;p&gt;We already handle this concept to some extent.  For example, here’s what the NSIS installer displays when Java isn’t already installed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/ncdns-nsis/spv-missing-java-2018-08-10.png&quot; alt=&quot;&amp;quot;Cannot use BitcoinJ SPV client (Java must be installed)&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Compare this to the typical display when Java &lt;em&gt;is&lt;/em&gt; installed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/ncdns-nsis/select-spv-dnssec-trigger-2018-07-31.png&quot; alt=&quot;&amp;quot;Install and use the BitcoinJ SPV client (lighter, less secure)&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, over the last day or so, I hacked on the ncdns NSIS script to make it detect the Microsoft Visual C++ 2010 Redistributable Package (like we already do for Java), and refuse to install ConsensusJ-Namecoin if it’s not found:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/ncdns-nsis/spv-missing-vc2010-2018-08-10.png&quot; alt=&quot;&amp;quot;Cannot use BitcoinJ SPV client (Microsoft Visual C++ Redistributable Package must be installed)&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This was an excellent excuse for me to get some more experience with NSIS.  Hopefully it saves some users from head-banging confusion.&lt;/p&gt;

&lt;p&gt;(It should be noted, of course, that the “right way” to solve this is to actually make ConsensusJ-Namecoin not require any non-free Microsoft dependencies.  This is something we’ll probably look into as we move towards reproducible builds.  That said, Windows users are already trusting non-free Microsoft code, so this isn’t as big a deal as one might think.)&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/08/14/ncdns-nsis-ux-detect-msvc2010.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/08/14/ncdns-nsis-ux-detect-msvc2010.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>cross_sign_name_constraint_tool Drops Support for Go v1.9.x; Users Who Self-Built It With Go v1.9.x Should Update Immediately</title>
        <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt;, as you may remember, is a Namecoin-developed tool that applies name constraints to a certificate authority, without requiring any permission from that CA.  It can be used to prevent malicious CA’s from issuing certificates for Namecoin domain names, even if those CA’s are trusted for DNS domain names.  &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; (or its underlying library) is used by other Namecoin projects, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; (which integrates &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; with the NSS cert store used by Firefox and the GNU/Linux version of Chromium) and ncdns (which will soon make &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; easy to use on Windows).  &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt;’s official binaries are produced using Go v1.10.x.  Recently, I happened to notice a bug in Go v1.9.x (which is fixed in Go v1.10.0 and higher) that causes &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; to fail with an error like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error generating cross-signed CA: Couldn't unmarshal original certificate: asn1: structure error: tags don't match (2 vs {class:0 tag:16 length:13 isCompound:true}) {optional:false explicit:false application:false defaultValue:&amp;lt;nil&amp;gt; tag:&amp;lt;nil&amp;gt; stringType:0 timeType:0 set:false omitEmpty:false}  @21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The error only occurs with a small subset of CA certificates; the specific CA that triggered this error for me was &lt;code class=&quot;highlighter-rouge&quot;&gt;Verisign Class 3 Public Primary Certification Authority - G3&lt;/code&gt; (which is trusted by Fedora).&lt;/p&gt;

&lt;p&gt;This bug doesn’t affect users of our official binaries, because the official binaries weren’t built with an affected Go version.  My WIP ncdns PR for automatically integrating &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; would have made such an error very obvious: it causes ncdns to stop resolving &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; domains when such an error is observed, so there’s no risk to users from name constraints being incompletely applied.  However, users who built their own &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; using Go 1.9.x, and who failed to notice a prominent error message when running it, would potentially be left incompletely protected from the threats that &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; is designed to protect against.&lt;/p&gt;

&lt;p&gt;If you’re running a self-built &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt; that was built with Go 1.9.x, I strongly recommend that you rebuild with Go 1.10.x and re-apply your desired name constraints.  I don’t have any reason to believe that any CA has exploited this in the wild.  (Any CA who tried to exploit it would probably have been detected by certificate transparency.)  And remember, &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt; is designed to protect against attacks that users of the DNS are &lt;em&gt;completely&lt;/em&gt; vulnerable to – this bug is not a downgrade from the security model of the DNS.  (Indeed, even with this bug, affected users were still protected from a random subset of their system’s trusted CA’s, so security in this aspect was still somewhat higher than that of the DNS.)&lt;/p&gt;

&lt;p&gt;I’ve submitted a test case to &lt;code class=&quot;highlighter-rouge&quot;&gt;cross_sign_name_constraint_tool&lt;/code&gt;, which will ensure that anyone who tries to build it with an affected Go version will receive a test failure.  ncdns will also be updated to use Go 1.10.x prior to the release that integrates &lt;code class=&quot;highlighter-rouge&quot;&gt;tlsrestrict_nss_tool&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Aug 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/08/13/cross-sign-name-constraint-tool-drops-support-go-v1.9.x-update-immediately.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/08/13/cross-sign-name-constraint-tool-drops-support-go-v1.9.x-update-immediately.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: Name Script Deserialization</title>
        <description>&lt;p&gt;I previously wrote about &lt;a href=&quot;/2018/07/15/electrumx-name-scripts.html&quot;&gt;making ElectrumX (the server) handle name scripts&lt;/a&gt;.  Now that that’s out of the way, the next step is making Electrum-NMC (the client) handle name scripts as well.  I now have Electrum-NMC deserializing name scripts.&lt;/p&gt;

&lt;p&gt;Most of the details of this work are fairly mundane implementation details that probably won’t interest most readers.  So, instead, how about a screenshot?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/screenshots/electrum-nmc/2018-07-17-Names-in-History-Tab.png&quot; alt=&quot;A screenshot of name transactions visible in the Electrum-NMC History tab.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/08/06/electrum-nmc-name-script-deserialization.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/08/06/electrum-nmc-name-script-deserialization.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin's Jeremy Rand will be at Decentralized Web Summit 2018</title>
        <description>&lt;p&gt;Namecoin developer Jeremy Rand will attend &lt;a href=&quot;https://decentralizedweb.net/&quot;&gt;Decentralized Web Summit 2018&lt;/a&gt; in San Francisco, July 31 - August 2, hosted by the &lt;a href=&quot;https://archive.org/&quot;&gt;Internet Archive&lt;/a&gt;.  Namecoin will be at the &lt;a href=&quot;https://decentralizedwebsummit2018.sched.com/event/FMJT/science-fair&quot;&gt;Science Fair&lt;/a&gt; and will give a Lightning Talk (schedule TBA).  We’re also open to meetups and hacking sessions independent of the official DWS schedule, so if you’re attending DWS (or if you’re in the SF area) and would like to chat or hack, get in touch with us!  We’re looking forward to the Summit!&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/07/23/decentralized-web-summit-2018.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/07/23/decentralized-web-summit-2018.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>ElectrumX: Name Scripts</title>
        <description>&lt;p&gt;ElectrumX is the server component of Electrum.  Unlike the client component, which requires forking to enable altcoins, ElectrumX has altcoin support by default, including Namecoin &lt;a href=&quot;#footnote1&quot;&gt;[1]&lt;/a&gt;.  ElectrumX already supports the AuxPoW features of Namecoin (which is why &lt;a href=&quot;/2018/07/09/electrum-nmc-auxpow-verification.html&quot;&gt;only Electrum-NMC needed modifications&lt;/a&gt; for that), but name script support required some tweaks to ElectrumX.&lt;/p&gt;

&lt;p&gt;The main issue here is that the Electrum protocol requires Electrum to supply scriptPubKey hashes to ElectrumX, for which ElectrumX will then reply with transaction ID’s.  This works great when the scriptPubKey can be easily determined by the client (a Bitcoin address can be deterministically converted to a scriptPubKey), but in Namecoin, a scriptPubKey for a name output contains some extra data that Electrum-NMC won’t know ahead of time.  Specifically, a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; scriptPubKey includes the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_NAME_UPDATE&lt;/code&gt; opcode, the name identifier, the name value, an &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_2DROP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_DROP&lt;/code&gt; opcode to empty the opcode, identifier, and value from the stack, and &lt;em&gt;then&lt;/em&gt; a standard Bitcoin scriptPubKey that corresponds to the address that owns the name.  (A &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; scriptPubKey contains even more stuff.)  An Electrum-NMC client that wants to look up transactions by address won’t know the name identifier, and an Electrum-NMC client that wants to look up transactions by name identifier won’t know the address of the owner.  As a result, we need to mess with things.&lt;/p&gt;

&lt;p&gt;The approach I took was to tweak Namecoin’s altcoin definition in ElectrumX to do a few things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When hashing a scriptPubKey, first detect whether the scriptPubKey is a name script, and strip away the name script prefix if present.  This leaves only a standard Bitcoin-style scriptPubKey that can be looked up via the standard Electrum protocol.&lt;/li&gt;
  &lt;li&gt;Add a secondary method of hashing a scriptPubKey, which detects &lt;code class=&quot;highlighter-rouge&quot;&gt;name_anyupdate&lt;/code&gt; scripts, and rewrites them into a standard form that’s well-suited to name lookups (more on that below).&lt;/li&gt;
  &lt;li&gt;When indexing transactions, index the results of both the usual hashing method &lt;em&gt;and&lt;/em&gt; the secondary method, so that we can reuse ElectrumX’s transaction index for both address lookups and name identifier lookups.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How does this standard form work?  Here are the things it changes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; scripts are converted to &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; scripts; the extra data that &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; scripts contain is stripped.&lt;/li&gt;
  &lt;li&gt;The name value is replaced with an empty string.  (Technically this means that we use &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_0&lt;/code&gt; instead of the usual push operation.)&lt;/li&gt;
  &lt;li&gt;The Bitcoin-style scriptPubKey after the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_DROP&lt;/code&gt; is replaced with &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_RETURN&lt;/code&gt;.  (Technically this would be interpreted as an unspendable scriptPubKey.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What are the advantages of this approach?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Name scripts can be looked up by identifier using the standard Electrum protocol commands; no changes to Electrum’s protocol are needed.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; can both be looked up by the same Electrum protocol command.&lt;/li&gt;
  &lt;li&gt;The scripts being hashed are unambiguously name scripts, and are not going to appear by accident in other contexts.  It is, of course, certainly possible to deliberately produce a name script whose address is another name script followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_RETURN&lt;/code&gt;, but Electrum’s protocol isn’t intended to prevent deliberate collisions anyway.  Any such weird transactions will be detectable when they’re downloaded by Electrum-NMC, just like other colliding scripts.  Using &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_RETURN&lt;/code&gt; as the scriptPubKey also makes it expensive for spammers to produce such collisions, because it means you need to destroy a name (thereby forfeiting your name registration fee) for each collision that you produce.&lt;/li&gt;
  &lt;li&gt;The script hash doesn’t trivially reveal what name is being looked up; it only reveals a hash.  This improves privacy and security when the name being looked up doesn’t actually exist yet in the blockchain (e.g. if you’re checking whether a name you want to register already exists).  It should be noted, however, that constructing a rainbow table for this hash function is straightforward, so if it’s critical that the names you’re looking up not be revealed to the ElectrumX server, you’re better off doing lookups via ConsensusJ-Namecoin’s &lt;code class=&quot;highlighter-rouge&quot;&gt;leveldbtxcache&lt;/code&gt; mode instead of the Electrum protocol.  On the other hand, ElectrumX can’t actually determine whether the names being looked up are being used for DNS resolution or for registration purposes, so this might disincentivise ElectrumX servers from trying to frontrun registrations, since there’ll be a hell of a lot of noise from DNS-resolution-sourced lookups.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Generally speaking, ElectrumX’s altcoin abstractions were very pleasant to work with (kudos to Neil Booth and the other ElectrumX contributors on this!), and making these changes wasn’t too hard.  Test results:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ElectrumX takes noticeably longer to sync from Namecoin Core with these changes, but in practical terms the difference isn’t a problem: it’s 33 minutes instead of 12 minutes on my &lt;a href=&quot;https://www.raptorcs.com/&quot;&gt;Talos II&lt;/a&gt;.  (There might be ways to optimize the speed; I haven’t tried to do any optimizations yet.)&lt;/li&gt;
  &lt;li&gt;Looking up name transaction ID’s by address can be done via the Electrum-NMC console with no changes to Electrum-NMC.&lt;/li&gt;
  &lt;li&gt;Looking up name transaction ID’s by name identifier can be done via the Electrum-NMC console via the (present in upstream but undocumented) &lt;code class=&quot;highlighter-rouge&quot;&gt;network.get_history_for_scripthash&lt;/code&gt; command.  However, this requires manually constructing a standard-form scriptPubKey hash from the name identifier, which isn’t exactly a fun process for those of us who don’t consider Bitcoin script as a native language.&lt;/li&gt;
  &lt;li&gt;Looking up unconfirmed name transactions doesn’t yet work, because my patch to ElectrumX doesn’t yet cover the UTXO index, only the history index.  I haven’t tried to fix this yet, and I might not bother for a while, since unconfirmed name transactions aren’t really trustworthy unless you’re verifying signatures relative to older transactions for that name (such a technique was first proposed years ago by Ryan Castellucci, but to my knowledge no one has actually deployed it yet).&lt;/li&gt;
  &lt;li&gt;The procedure for obtaining full transactions from transaction ID’s, and for obtaining Merkle proofs for those transactions, is considered out of scope for this work, because Electrum’s protocol already supports this, and shouldn’t need anything name-specific.  However, it might be interesting to combine those commands with the script hash lookup commands into a single wire protocol command to reduce latency (an interesting area of future work).&lt;/li&gt;
  &lt;li&gt;The procedure for parsing name transactions (either for wallet or name lookup purposes) after ElectrumX returns them is considered out of scope for this work, because that should be done by Electrum-NMC; this work only covers changes to ElectrumX.  The needed changes to Electrum-NMC will come later.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I intend to submit these changes to upstream ElectrumX as a PR.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;

&lt;div id=&quot;footnote1&quot;&gt;

[1] I actually don't like to refer to Namecoin as an &quot;altcoin&quot;, since the term means an &quot;alternative&quot; to Bitcoin, and Namecoin doesn't aim to achieve any of the use cases that Bitcoin does.  However, on a purely technical level, the process of adding Namecoin support to ElectrumX wasn't any different from most altcoins such as Dogecoin, so the umbrella of &quot;altcoin support&quot; does include Namecoin, as much as I dislike the public-relations implications of that label.

&lt;/div&gt;
</description>
        <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/07/15/electrumx-name-scripts.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/07/15/electrumx-name-scripts.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC v3.2.2 Released</title>
        <description>&lt;p&gt;We’ve released Electrum-NMC v3.2.2.  Here’s what’s new:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Trezor support.&lt;/li&gt;
  &lt;li&gt;Support AuxPoW and timewarp hardforks.  (AuxPoW is still experimental, but it does successfully sync now.)&lt;/li&gt;
  &lt;li&gt;Fix running the GNU/Linux release without installing first.&lt;/li&gt;
  &lt;li&gt;Improvements from upstream Electrum.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please note that due to a bugfix that was needed for Trezor support, any coins stored in wallets from older versions of Electrum-NMC will probably be inaccessible from this version.  We recommend that you empty your old Electrum-NMC wallets into Namecoin Core prior to installing this version, and then recreate your Electrum-NMC wallets after installing this version.&lt;/p&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/#electrum-nmc&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs.&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/07/12/electrum-nmc-v3.2.2-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/07/12/electrum-nmc-v3.2.2-released.html</guid>
        
        <category>Releases</category>
        
        <category>Electrum Releases</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: AuxPoW Verification</title>
        <description>&lt;p&gt;Previously, I covered &lt;a href=&quot;/2018/07/01/electrum-nmc-auxpow.html&quot;&gt;AuxPoW deserialization in Electrum-NMC&lt;/a&gt;.  The next steps are on-disk serialization/deserialization, and verifying the deserialized AuxPoW.  These are now implemented.&lt;/p&gt;

&lt;p&gt;It turned out that on-disk serialization/deserialization was a lot easier than anticipated, because Electrum only writes headers to disk &lt;em&gt;after&lt;/em&gt; they’ve been verified, and it never reverifies them.  So it was sufficient to simply strip the AuxPoW portion of the headers prior to writing them to disk, and to tweak the header deserialization code so that it won’t error when it encounters AuxPoW-enabled headers that don’t have AuxPoW data (this is secure since even if such headers are successfully deserialized, they would never pass verification if verification were attempted).&lt;/p&gt;

&lt;p&gt;Next up, AuxPoW verification!&lt;/p&gt;

&lt;p&gt;AuxPoW verification code was already present in Electrum-DOGE, and it was relatively straightforward to port over to the current Electrum codebase.  In the process, however, I noticed that Electrum-DOGE has a dependency &lt;a href=&quot;https://pypi.org/project/btcutils/&quot;&gt;on a library called &lt;code class=&quot;highlighter-rouge&quot;&gt;btcutils&lt;/code&gt;&lt;/a&gt;.  I can’t find that library’s source code on GitHub, nor does the PyPI page indicate a Git repository, an issue tracker, or even a license.  At worst, this might indicate a GPL violation in Electrum-DOGE; at best, this indicates that the library has probably never been audited and is unwise to rely on.  As a result, I re-implemented from scratch the single function in that library that Electrum-DOGE was using.&lt;/p&gt;

&lt;p&gt;After implementing AuxPoW verification in Electrum-NMC, I received a &lt;code class=&quot;highlighter-rouge&quot;&gt;bits&lt;/code&gt; mismatch error during blockchain verification (some time after AuxPoW activated).  This was, of course, due to the “time warp” difficulty retargeting hardfork that Namecoin adopted long ago.  (Since I was the author of the time warp hardfork support in libdohj, fixing this in Electrum-NMC was quite straightforward.)&lt;/p&gt;

&lt;p&gt;Next, I noticed that verification of AuxPoW headers was incredibly slow.  Some use of profiling tools revealed a number of bottlenecks (mostly relatively boring stuff like unneeded hex/binary conversions and unneeded copy operations), which I fixed.&lt;/p&gt;

&lt;p&gt;At this point, I decided to do a full sync from scratch to see if it verified the entire blockchain.  Unfortunately, it failed at chunk 77, due to an error from the ElectrumX server indicating that the response exceeded the server’s configured 5 MB limit.  I infer that there were a bunch of unusually large Bitcoin coinbase transactions around that point in Bitcoin’s history.  Luckily, the operator of the public Namecoin ElectrumX server quickly replied to my email and raised the limit.  At this point, Electrum-NMC was able to fully sync.&lt;/p&gt;

&lt;p&gt;In terms of performance, Electrum-NMC on my &lt;a href=&quot;https://www.raptorcs.com/&quot;&gt;Talos II&lt;/a&gt; is able to sync from scratch in about 6 minutes, without using any checkpoints (other than the genesis checkpoint).&lt;/p&gt;

&lt;p&gt;Since Namecoin is a good neighbor, I’m maintaining an &lt;code class=&quot;highlighter-rouge&quot;&gt;auxpow&lt;/code&gt; branch in the Electrum-NMC Git repository, which is identical to upstream Electrum except that AuxPoW support is added.  This may be useful to other AuxPoW-based cryptocurrencies who want a starting point for porting Electrum to their cryptocurrency.  (Daniel already does something similar for Namecoin Core.)&lt;/p&gt;

&lt;p&gt;It should be noted that I haven’t carefully audited the components inherited from Electrum-DOGE, so the AuxPoW support in Electrum-NMC should not be relied on in critical applications – it would not be surprising if Electrum-DOGE’s AuxPoW code is slightly consensus-incompatible with Namecoin Core.  Verifying that is on my to-do list.&lt;/p&gt;

&lt;p&gt;The next step in Electrum-NMC is adding support for name scripts.  That will be covered in a future post.&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jul 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/07/09/electrum-nmc-auxpow-verification.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/07/09/electrum-nmc-auxpow-verification.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>The Great Namecoin Mining Brownout of June 17-20, 2018: Postmortem</title>
        <description>&lt;p&gt;Recently, many Namecoin mining pools experienced an outage, causing transaction confirmation to slow down to 2.1 blocks/hour.  We’ve fixed the issue, and mining is back to normal.  This post summarizes what we know about the outage.&lt;/p&gt;

&lt;h2 id=&quot;the-cause&quot;&gt;The Cause&lt;/h2&gt;

&lt;p&gt;On June 17, an unknown person appears to have built a pair of &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transactions with the raw transaction API, and broadcast them both to the Namecoin P2P network at the same time.  This is not something that the normal Namecoin Core GUI or RPC API will let you do, because revealing your &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transaction before the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; has been confirmed allows 3rd parties to front-run your registration.  However, there’s nothing that prevents users from doing this via the raw transaction API.  Namecoin Core’s consensus rules require &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transactions to wait 12 blocks after &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; before they can be mined; any &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transactions whose &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; input doesn’t yet have 12 confirmations will be admitted to the memory pool but will not be mined.  Unfortunately, there was a bug in Namecoin Core’s mining code: while it was correctly choosing not to mine &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transactions whose &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; input had between 1 and 11 (inclusive) confirmations, it was erroneously trying to mine &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transactions whose &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; input had zero confirmations.  As a result, &lt;code class=&quot;highlighter-rouge&quot;&gt;getblocktemplate&lt;/code&gt; was building an invalid block, and then returning an error upon detecting that the block was invalid, which DoSed the mining pools.&lt;/p&gt;

&lt;h2 id=&quot;our-initial-response&quot;&gt;Our Initial Response&lt;/h2&gt;

&lt;p&gt;Cassini reported on June 18 that, during the prior 24 hours, only ViaBTC and BTC.COM had mined any Namecoin blocks.  He wasn’t sure what the cause of the outage was, but he did note that it didn’t seem to be related to BTC versus BCH mining, since ViaBTC was still using both parent chains for Namecoin mining as usual.  The obvious thing to do was to contact the mining pools to figure out whether they were seeing any errors on their end.  Jeremy began contacting the mining pools.  While we were waiting for mining pools to respond, we tried to analyze possible failure modes.  Cassini speculated that maybe an accidental consensus fork had occurred, and wondered whether the two pools who were still online had changed anything about their setup recently (e.g. updating their Bitcoin Core or Namecoin Core client).  Jeremy noted that clearly the pools who were still online hadn’t accidentally activated a hardfork, since Jeremy’s Namecoin Core node from 2 years ago was still accepting their blocks.  To verify whether an accidental softfork had been activated, Jeremy asked Redblade7 (who runs a Namecoin seed node) to check the output of &lt;code class=&quot;highlighter-rouge&quot;&gt;namecoin-cli getchaintips&lt;/code&gt;.  The output revealed that no forks had been observed since June 3 (and that fork was only a single orphaned block), which made it clear that no softfork had occurred.  (In addition, the two pools who were still up composed a minority of the usual hashrate, which again pointed to this not being an accidental softfork.)&lt;/p&gt;

&lt;h2 id=&quot;response-from-miners&quot;&gt;Response from Miners&lt;/h2&gt;

&lt;p&gt;Wang Chun from F2Pool was the first mining pool operator to get back to us; he said F2Pool was investigating the issue from their side.  Shortly afterward, F2Pool’s mining came back online and mined 6 blocks.  Shortly afterward, crackfoo of zpool posted on GitHub saying that he was repeatedly getting &lt;code class=&quot;highlighter-rouge&quot;&gt;getblocktemplate&lt;/code&gt; errors that day.  crackfoo posted this in a GitHub issue that was fairly old: mining pools had occasionally been receiving that error for well over a year, but it had been difficult to reproduce.  However, the last post in that thread prior to crackfoo’s was from Yihao Peng of BTC.COM on June 17, saying that he had gotten the error that day and had fixed it by clearing his memory pool.  Yihao Peng’s post was the first one that provided debug logs, which allowed us to analyze what was happening.  Daniel quickly figured out that the issue was caused by the unconfirmed &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; pair, and Jeremy speculated that this was probably the reason for the outage.&lt;/p&gt;

&lt;h2 id=&quot;immediate-fixes&quot;&gt;Immediate Fixes&lt;/h2&gt;

&lt;p&gt;crackfoo asked whether there was any way to exclude the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; from block creation as a temporary fix while we were waiting for a Namecoin Core update.  Jeremy suggested using the &lt;code class=&quot;highlighter-rouge&quot;&gt;prioritisetransaction&lt;/code&gt; RPC call to prevent the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; from being included in blocks.  Jeremy then tested this locally, and verified that it fixed mining; Jeremy sent out a message to the Alerts mailing list notifying mining pools  that they could restore service by doing this.  Jeremy also suggested using &lt;code class=&quot;highlighter-rouge&quot;&gt;prioritisetransaction&lt;/code&gt; to accelerate the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction, since once it got mined, the problem would go away (even for mining pools who didn’t do anything).  Yihao Peng from BTC.COM offered to do so, and successfully mined the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction on June 20.  At this point, we observed the rest of the mining pools come back online.&lt;/p&gt;

&lt;h2 id=&quot;proper-fixes&quot;&gt;Proper Fixes&lt;/h2&gt;

&lt;p&gt;Daniel has fixed the relevant behavior in Namecoin Core’s block construction code; the fix is present in both the &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;0.16&lt;/code&gt; branches.  Miners are encouraged to upgrade so that this situation can’t happen again.&lt;/p&gt;

&lt;h2 id=&quot;analysis&quot;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;Obviously, any kind of mining disruption is a bad thing, since it causes transactions to confirm more slowly and also increases exposure of the Namecoin network to potential 51% attacks.  In particular, when only 2 mining pools are mining blocks for a period of a day, the larger of the two pools obviously has the capacity to double-spend transactions.  We’re not aware of any reason to believe that any double-spend attacks occurred, which is consistent with our general experience that the Namecoin mining pools behave ethically and try to help us fix issues.  (AuxPoW researchers Paul Sztorc and Alexey Zamyatin have come to similar conclusions about Namecoin mining pools.)  In particular, BTC.COM (the pool that would have been capable of double-spending) was also the pool who reported debug logs to us and accelerated the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction to fix the problem for the other pools.&lt;/p&gt;

&lt;p&gt;Generally speaking, our incident response went quite well.  In particular, service stayed up and running throughout the 3-day incident, although it took ~3x longer to get transactions to confirm than usual.  Compared to &lt;a href=&quot;/2014/09/09/great-aggregating-postmortem.html&quot;&gt;the previous notable outage, from 2014&lt;/a&gt;, where the network was totally unusable for 2 weeks, things certainly went a lot better this time around.  However, we wouldn’t be doing our jobs if we didn’t propose some additional steps we can take to further improve:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Streamline the process of contacting mining pools.  We already have an alerts mailing list that was set up long ago, but the alerts list is ill-suited to cases where we suspect a problem with a particular mining pool and don’t want to spam the other pools with noise.  Improving this is already on our radar, due to some upcoming softforks (yes, we’re finally activating P2SH and SegWit soon!) on which we need to closely coordinate with mining pools (and other service providers, such as exchanges, registrars, block explorers, ElectrumX operators, inproxies like OpenNIC, and analytic websites like CoinMarketCap, BitName.ru, and Blockchain-DNS.info).&lt;/li&gt;
  &lt;li&gt;Automated monitoring.  Significant progress was made on this since the 2014 outage.  In particular, we have a free software script that can calculate hashrate distribution, and Cassini runs this script regularly.  However, that script is not maintained as well as it should be (both Cassini and Jeremy have some private changes that haven’t yet been merged due to lack of time to devote to it), and it would be beneficial to document exactly how to run the script in an automated fashion, with things like email or Matrix alerts when suspicious events occur.  We’re currently in the middle of re-evaluating our CI infrastructure (yes, we are aware of the GitHub buyout by a PRISM member and ICE supplier, and we’re not happy about it), and this is definitely one area that we’ll be exploring.  Coincidentally, several of our developers recently obtained a &lt;a href=&quot;https://www.raptorcs.com/&quot;&gt;Talos II from Raptor Computing Systems&lt;/a&gt; (yes, they are awesome, you should support Raptor), so this may give us additional infrastructure options.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And, to complement the above, some things that &lt;em&gt;aren’t&lt;/em&gt; critically needed for this particular issue:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Quick release of binaries for emergency fixes.  While this &lt;em&gt;would&lt;/em&gt; be highly useful for other reasons (and we’re exploring this possibility for CI infrastructure), we’ve been sufficiently successful at making Namecoin Core build reliably from source that the mining pools usually build Namecoin Core themselves.  At the time of the 2014 outage, Namecoin was a pain in the rear to build and a lot of mining pools were using our binaries.  Not a problem anymore.&lt;/li&gt;
  &lt;li&gt;Adopt support for Matt Corallo’s decentralized pooled mining protocol.  While this would have substantial benefits in terms of both total hashrate and hashrate diversity, the problem at the root of this issue is a matter of (1) effective communication with miners and (2) attentive miners, both of which are made mildly worse by a more diverse hashrate distribution.  We do intend to pursue this as a long-term goal (it’s a hardfork, meaning that adopting it is a major bother), and we think it’s highly important for Namecoin to improve in this area, even though a more diverse hashrate is less effective for communication and attentiveness.&lt;/li&gt;
  &lt;li&gt;Contingency plans for developers who are busy with external obligations.  Although more redundancy is always helpful, we currently have some developers who have sufficient funding for Namecoin to be their primary project.  This was not the case in 2014, when our primary responders were dealing with unrelated business trips or school coursework.  As a result, response to critical issues is substantially more reliable now than it was 4 years ago.  Don’t get me wrong, we still need more developers, and we still would benefit from more funding – but things are clearly moving in the right direction.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;p&gt;The following people helped respond to the outage:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cassini&lt;/li&gt;
  &lt;li&gt;Jeremy Rand&lt;/li&gt;
  &lt;li&gt;Daniel Kraft&lt;/li&gt;
  &lt;li&gt;Yihao Peng (BTC.COM)&lt;/li&gt;
  &lt;li&gt;crackfoo (zpool)&lt;/li&gt;
  &lt;li&gt;Wang Chun (F2Pool)&lt;/li&gt;
  &lt;li&gt;Redblade7&lt;/li&gt;
  &lt;li&gt;Luke Dashjr&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/07/08/brownout-june-17-20.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/07/08/brownout-june-17-20.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC: AuxPoW Deserialization</title>
        <description>&lt;p&gt;Namecoin’s merged mining, which allows miners to simultaneously mine a parent chain (usually Bitcoin) and any number of child chains (e.g. Namecoin and Huntercoin), is made possible by AuxPoW (auxilliary proof of work).  AuxPoW is a clever trick (first proposed by Bitcoin founder Satoshi Nakamoto, and first implemented by Namecoin founder Vincent Durham) that allows a block in the parent chain to commit to a block in any number of child chains, such that the child block can reference the parent block’s PoW and thereby prove that the PoW committed to both the parent and child block.  AuxPoW doesn’t impose any changes for the parent chain’s consensus rules, but it does constitute a hardfork for the child chain (even for lightweight SPV clients of the child chain).  As a result, making Electrum-NMC validate PoW properly requires patching Electrum to support AuxPoW.&lt;/p&gt;

&lt;p&gt;Recently I started hacking on Electrum-NMC to support AuxPoW.  This is not an entirely new problem; a previous Electrum fork (&lt;a href=&quot;https://github.com/electrumalt/electrum-doge&quot;&gt;Electrum-DOGE&lt;/a&gt;) already tried to implement AuxPoW.  Unfortunately, Electrum-DOGE’s code quality is not exactly up to my standards, and besides that, it’s a fork of a 3.5-year-old version of Electrum.  Electrum has evolved substantially since then, to the point that a straightforward merge isn’t possible.  Additionally, it’s not clear how many people have actually audited Electrum-DOGE for correctness.  That said, Electrum-DOGE’s implementation is definitely a useful reference for determining how to do AuxPoW in Electrum.&lt;/p&gt;

&lt;p&gt;Upon adding some debug output to Electrum-NMC, I observed that the first error that showed up was in deserializing block headers.  This makes sense, since in Bitcoin, all block headers are exactly 80 bytes, whereas in Namecoin, the 80 bytes are optionally followed by a variable-length AuxPoW header, which includes things such as the parent block’s header, the parent block’s coinbase transaction (variable length), and two Merkle branches (also variable length).  Electrum-DOGE’s code for deserializing block headers wasn’t directly mergeable, but it definitely was sufficient reference material to implement AuxPoW header deserialization in Electrum-NMC.&lt;/p&gt;

&lt;p&gt;The next error that showed up was related to deserializing &lt;strong&gt;chunks&lt;/strong&gt; of block headers.  Electrum groups block headers into chunks, where each chunk corresponds to a difficulty period (2016 block headers).  Electrum was, of course, assuming in the chunking code that a chunk was exactly &lt;code class=&quot;highlighter-rouge&quot;&gt;2016 * 80&lt;/code&gt; bytes, which wasn’t going to work with AuxPoW.  Fixing this was straightforward enough that I did so without using Electrum-DOGE as a reference (the chunking code has evolved enough in the last 3.5 years that using Electrum-DOGE as a reference would probably have taken more time than reimplementing from scratch).&lt;/p&gt;

&lt;p&gt;The next step is dealing with serialization/deserialization of block headers to/from disk.  Naturally, Electrum’s block header storage format assumes 80-byte headers, so fixing that will take some work.&lt;/p&gt;

&lt;p&gt;There’s also a licensing side effect of using Electrum-DOGE as a reference.  Electrum’s license used to be GPLv3+, but since then they’ve relicensed to MIT.  Electrum-DOGE was forked from Electrum before the license change, and Electrum-DOGE’s authors never relicensed.  As a result, the code I wrote that’s based on Electrum-DOGE’s codebase is a derivative work of GPLv3+-licensed code.  All of the code from upstream Electrum, as well as all of Namecoin’s changes to Electrum and Electrum-DOGE, are still MIT-licensed, but the full combined work that constitutes Electrum-NMC is GPLv3-licensed.  This isn’t really a huge problem (GPLv3+ is a perfectly fine free software license, and I wasn’t intending to submit any of the AuxPoW code upstream anyway), but it’s definitely noteworthy.&lt;/p&gt;

&lt;p&gt;More Electrum AuxPoW work will be covered in future posts.&lt;/p&gt;

&lt;p&gt;This work was funded by Cyphrs.&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/07/01/electrum-nmc-auxpow.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/07/01/electrum-nmc-auxpow.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Electrum-NMC v3.1.3-beta1 Released</title>
        <description>&lt;p&gt;We’ve released Electrum-NMC v3.1.3-beta1.  This release supports Namecoin currency transactions, but does not yet support AuxPoW or name transactions.  This release is based on work by both ahmedbodi and myself.&lt;/p&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/#electrum-nmc&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Jun 2018 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2018/06/07/electrum-nmc-v3.1.3-beta1-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2018/06/07/electrum-nmc-v3.1.3-beta1-released.html</guid>
        
        <category>Releases</category>
        
        <category>Electrum Releases</category>
        
        
      </item>
    
  </channel>
</rss>
