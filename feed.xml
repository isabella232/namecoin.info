<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namecoin</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>https://namecoin.org//</link>
    <atom:link href="https://namecoin.org//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 11 Oct 2017 02:08:06 +0000</pubDate>
    <lastBuildDate>Wed, 11 Oct 2017 02:08:06 +0000</lastBuildDate>
    <generator>Jekyll v3.6.0</generator>
    
      <item>
        <title>Namecoin TLS for Firefox: Phase 4 (Fun with Threads)</title>
        <description>&lt;p&gt;In &lt;a href=&quot;/2017/09/30/firefox-tls-webext.html&quot;&gt;Phase 2&lt;/a&gt; of Namecoin TLS for Firefox, I mentioned that negative certificate verification overrides were expected to be near-identical in code structure to the positive overrides that I had implemented.  However, as is par for the course, Murphy’s Law decided to rear its head (but Murphy has been defeated for now).&lt;/p&gt;

&lt;p&gt;The specific issue I encountered is that while positive overrides are called from the main thread of Firefox, negative overrides are called from a thread dedicated to certificate verification.  WebExtensions Experiments always run on the main thread.  This means that the naive way of accessing an Experiment from the C++ function that would handle negative overrides causes Firefox to crash when it detects that the Experiment is being called from the wrong thread.&lt;/p&gt;

&lt;p&gt;Luckily, I had recently gained some experience doing synchronous cross-thread calls (it’s how the Experiment calls the WebExtension), and converting that approach from JavaScript to C++ wasn’t incredibly difficult.  (The only irritating part was that the Mozilla wiki’s C++ sample code for this hasn’t been updated for years, and Mozilla’s API has made a change since then that makes the sample code fail to compile.  It wasn’t too hard to figure out what was broken, though.)&lt;/p&gt;

&lt;p&gt;After doing this, I was able to get my WebExtensions Experiment to trigger negative certificate verification overrides.&lt;/p&gt;

&lt;p&gt;Meanwhile, I talked with David Keeler from Mozilla some more about performance, and it became clear that some additional latency optimizations beyond &lt;a href=&quot;/2017/10/07/firefox-tls-latency.html&quot;&gt;Phase 3&lt;/a&gt; were going to be highly desirable.  So, I started optimizing.&lt;/p&gt;

&lt;p&gt;The biggest bottleneck in my codebase was that basically everything was synchronous.  That means that Firefox verifies the certificate according to its normal rules, and only then passes the certificate to my WebExtensions Experiment and has to wait for the Experiment to reply before Firefox can proceed.  Similarly, the WebExtensions Experiment has to wait for the WebExtension to reply before the Experiment can reply to Firefox.  This means 2 layers of cross-thread synchronous calls, one of which is entirely in JavaScript (and is therefore less efficient).&lt;/p&gt;

&lt;p&gt;The natural solution is to try to make things asynchronous.  I decided to start with making the Experiment’s communication with the WebExtension asynchronous.  This works by adding a new non-blocking function to the Experiment (called from C++), which simply notifies it that a new certificate has been seen.  This is called immediately after Firefox passes the certificate to its internal certificate verifier (and before Firefox’s verification happens), which allows the Experiment and the WebExtension to work in parallel to Firefox’s certificate verifier.  When the WebExtension concludes whether an override is warranted, it notifies the Experiment, which stores the result in a cache (right now this cache is a memory leak; periodically clearing old entries in the cache is on the to-do list).&lt;/p&gt;

&lt;p&gt;Once Firefox has finished verifying the certificate, it asks the Experiment for the override decision, but now the Experiment is likely to already have the required data (or at least be a lot closer to having it).  The C++ to Experiment cross-thread call is still synchronous (for now), but the impact on overall latency is greatly reduced.&lt;/p&gt;

&lt;p&gt;Unfortunately, at this point Murphy decided he wanted a rematch.  My code was consistently crashing Firefox sometime between the C++ code issuing a call to the Experiment and the Experiment receiving the call.  I guessed that this was a thread safety issue (Mozilla doesn’t guarantee that the socket info or certificate objects are thread-safe).  And indeed, once I modified my C++ code to duplicate the relevant data rather than passing a pointer to a thread, this was fixed.  Murphy didn’t go away without a fight though – it looks like Mozilla’s pointer objects also aren’t thread-safe, so I needed to use a regular C++ pointer instead of Mozilla’s smart pointers.  (For now, that means that my code has a small memory leak.  Obviously that will be fixed later.)&lt;/p&gt;

&lt;p&gt;After doing all of the above, I decided to check performance.  On both my Qubes installation and my bare-metal Fedora live system, the latency from positive overrides is now greatly reduced.  Below are graphs of the latency added by positive overrides on my bare-metal Fedora live system:&lt;/p&gt;

&lt;object data=&quot;/data/webextensions-latency/2017-10-07/graph-uncached.svg&quot; type=&quot;application/svg+xml&quot;&gt;&lt;img src=&quot;/data/webextensions-latency/2017-10-07/graph-uncached.png&quot; /&gt;&lt;/object&gt;

&lt;object data=&quot;/data/webextensions-latency/2017-10-07/graph-cached.svg&quot; type=&quot;application/svg+xml&quot;&gt;&lt;img src=&quot;/data/webextensions-latency/2017-10-07/graph-cached.png&quot; /&gt;&lt;/object&gt;

&lt;p&gt;The graphs appear to show a noticeable speedup over time.  Part of this is likely to be attributable to the JavaScript JIT warming up.  Another part of it may be an artifact of the script I used to make Firefox verify the certificates: I first did 3 batches of 5 certs, then a batch of 10 certs, then a batch of 20 certs, for a total of 45 certificate verifications.  The graphs also show that certificates that were previously cached tended to verify faster; this is because the cache is located in the Experiment rather than the WebExtension, which eliminates a cross-thread call.&lt;/p&gt;

&lt;p&gt;You can also take a look at the raw data used to generate these graphs &lt;a href=&quot;/data/webextensions-latency/2017-10-07/raw-data.ods&quot;&gt;in OpenDocument spreadsheet format&lt;/a&gt; or &lt;a href=&quot;/data/webextensions-latency/2017-10-07/raw-data.html&quot;&gt;in HTML format&lt;/a&gt;.  This also includes percentile analysis, as well as data roughly corresponding to &lt;a href=&quot;https://mzl.la/2hJH2Am&quot;&gt;Mozilla’s telemetry on how long certificate verification takes right now&lt;/a&gt;.  Although measurements on my Fedora system and from Mozilla telemetry aren’t directly comparable, it is noteworthy that the median overhead introduced by my changes is about 9% of the median certificate verification time measured by Mozilla telemetry.&lt;/p&gt;

&lt;p&gt;It should be noted that this data is not intended to be scientifically reproducible; there are likely to be differences between setups that could impact the latency significantly, and I made no effort to control for or document such differences.  That said, it’s likely to be a useful indicator of how well we’re doing.  My opinion is that this is much, much closer to a performance impact that Mozilla would plausibly be willing to merge, compared to the performance before this optimization.  However, additional work is still warranted.  (And, of course, it’s Mozilla’s opinion, not mine, that matters here!)&lt;/p&gt;

&lt;p&gt;There are 2 additional major optimizations that I intend to do (which aren’t yet started):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Make the C++ to Experiment calls asynchronous.  This way, the C++ code doesn’t need to issue a synchronous cross-thread call to retrieve the override data from the Experiment.&lt;/li&gt;
  &lt;li&gt;Add an extra asynchronous call that lets Firefox notify the Experiment and the WebExtension as soon as it knows that a TLS handshake is likely to occur soon for a given domain name.  In Namecoin’s case, this gives the WebExtension a chance to ask ncdns for the correct certificate before Firefox even begins the TLS handshake.  That way, by the time the observed certificate gets passed to the WebExtension, it will be likely to already know how to verify it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point I’m not 100% certain whether I’ll choose to do more optimization next, or if I’ll focus on hooking the WebExtension into ncdns.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/10/10/firefox-tls-threads.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/10/10/firefox-tls-threads.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin TLS for Firefox: Phase 3 (Latency Debugging)</title>
        <description>&lt;p&gt;I &lt;a href=&quot;/2017/09/30/firefox-tls-webext.html&quot;&gt;recently mentioned&lt;/a&gt; performance issues that I observed with the Firefox TLS WebExtensions Experiment.  I’m happy to report that those performance issues appear to have been a false alarm, due to 2 main reasons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;I initially observed the performance issues in a Fedora VM inside Qubes.  I decided on a hunch to try the same code on a Fedora live ISO running on bare metal, and the worst-case latency decreased from ~20 ms to ~6 ms.  The spread also decreased a lot.  I can think of lots of reasons why Qubes might have caused performance issues, e.g. the use of CPU paravirtualization, the I/O overhead associated with Xen, the limit on logical CPU cores inside the VM, the use of memory ballooning, competition from other VM’s for memory and CPU, and probably lots of other reasons.  In any event, my opinion is that the fault here lies in Qubes, not my code.&lt;/li&gt;
  &lt;li&gt;The Firefox JavaScript JIT seems to improve performance of the WebExtensions Experiment and of the WebExtension each time it runs.  After running the same code (on bare-metal Fedora) against 6 different certificates, the latency decreased from ~6 ms to ~1 ms, and it was still monotonically decreasing at the 6th cert.  Testing this code with many repeats is tricky, because it caches validation results per host+certificate pair, and I don’t have a large supply of invalid certificates to test with.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The happy side effect of this debugging is that my current code is now quite a lot closer to Mozilla’s standard usage patterns, since I spent a lot of time trying to figure out whether something that I was deviating from Mozilla on was responsible for the latency.  Huge thanks to Andrew Swan from Mozilla for providing lots of useful tips in this area.&lt;/p&gt;

&lt;p&gt;I believe that there are still several optimizations that could be made to this code, but for now I’m reasonably satisfied with the performance.  (Whether Mozilla will want further optimization is unclear; I’ll ask them later.)  My next step will be to set up negative overrides in the WebExtensions Experiment and the WebExtension.  After that, I’ll be looking into actually making the WebExtension ask Namecoin for the cert data (instead of returning dummy data).  Then comes code cleanup, code optimizations, and a patch submission to Mozilla.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Oct 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/10/07/firefox-tls-latency.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/10/07/firefox-tls-latency.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Namecoin TLS for Firefox: Phase 2 (Overrides in a WebExtension)</title>
        <description>&lt;p&gt;As I &lt;a href=&quot;/2017/09/24/firefox-tls-cpp.html&quot;&gt;mentioned earlier&lt;/a&gt;, I’ve been hacking on a fork of Firefox that exposes an API for positive and negative certificate verification overrides.  When I last posted, I had gotten this working from the C++ end (assuming that a highly hacky and unclean piece of code counts as “working”).  I’ve now created a WebExtensions Experiment that exposes the positive override portion of this API to WebExtensions.  (Negative overrides are likely to be basically identical in code structure, I just haven’t gotten to it yet.)&lt;/p&gt;

&lt;p&gt;But wait, what’s a WebExtensions Experiment?  As you may know, Mozilla deprecated the extension model that’s been used since Firefox was created, in favor of a new model called WebExtensions, which is more cleanly segregated from the internals of Firefox.  This has some advantages: it means that WebExtensions can have a permission model rather than being fully trusted with the Firefox internals, and it also means that Firefox internals can change without requiring WebExtensions to adapt.  However, it also means that WebExtensions are significantly more limited in what they can do compared to old-style Firefox extensions.  WebExtensions Experiments are a bridge between the Firefox internals and WebExtensions.  WebExtensions Experiments are old-style Firefox extensions that happen to expose a WebExtensions API.  WebExtensions Experiments have all the low-level access that old-style Firefox extensions had; among other things, this means I can access my C++ API from a WebExtensions Experiment written in JavaScript, and expose an API to WebExtensions that allows them to indirectly access my C++ API.&lt;/p&gt;

&lt;p&gt;Creating the WebExtensions Experiment was relatively straightforward, given my prior experience with nczilla (remember, a WebExtensions Experiment is mostly just a standard old-style Firefox extension, like nczilla was).  I also created a proof-of-concept WebExtension that uses this API to make “Untrusted” errors be ignored.  While I was doing this, I also kept track of performance.  And therein lies the current problem.  When the Experiment simply returns an override without asking the WebExtension, the added overhead is generally 2 ms in the worst case (and often it’s much less than 1 ms).  Unfortunately, Experiments and WebExtensions run in separate threads, and the thread synchronization required to get them to communicate increases the overhead by an order of magnitude: the worst-case overhead is around 20 ms (and it’s very rarely less than 6 ms).&lt;/p&gt;

&lt;p&gt;My assumption was that there was no way Mozilla would be merging this with that kind of performance issue; this assumption was confirmed by David Keeler from Mozilla.&lt;/p&gt;

&lt;p&gt;On the bright side, it looks like there are several options for communicating between threads that should have lower latency (something like 1-2 ms overhead, assuming that documentation is accurate).  So I’ll be investigating those in the next week or two.&lt;/p&gt;

&lt;p&gt;As an interesting side note, Mozilla informs me that the current method I’m using to communicate between threads shouldn’t be working at all.  I’m not sure why it’s working when they say it shouldn’t, but in any event it’s probably a Very Bad Thing ™ to be using patterns that Mozilla doesn’t expect to work at all, even without the latency issue (since such patterns might break in the future, which I certainly don’t want).&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Sep 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/09/30/firefox-tls-webext.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/09/30/firefox-tls-webext.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Registering Names with the Raw Transaction API</title>
        <description>&lt;p&gt;The refactorings to the raw transaction API that I &lt;a href=&quot;/2017/09/13/raw-tx-api-refactoring.html&quot;&gt;mentioned earlier&lt;/a&gt; have been merged to Namecoin Core’s master branch.  I’ve been doing some experiments with it, and I used it to successfully register a name on a regtest network with only one unlock of my wallet (which covered both the &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; operations).&lt;/p&gt;

&lt;p&gt;I also coded support for Coin Control and Fee Control for name registrations, although this code is not yet tested (meaning that if Murphy has anything to say about it, it will need some fixes).&lt;/p&gt;

&lt;p&gt;So far the code here is a Python script, so it still needs to be integrated into Namecoin-Qt.  Brandon expects this to be relatively straightforward once I hand off my Python code to him.  Major thanks to Daniel for getting the API refactorings into Namecoin Core, and thanks to Brandon for useful discussions on how best to structure the code so that it can be integrated into Namecoin-Qt smoothly.&lt;/p&gt;

&lt;p&gt;Hopefully I’ll have more news on this subject in the next couple weeks.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Sep 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/09/28/raw-tx-api-registration.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/09/28/raw-tx-api-registration.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>ncdns v0.0.5 Released</title>
        <description>&lt;p&gt;We’ve released ncdns v0.0.5.  List of changes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows installer:
    &lt;ul&gt;
      &lt;li&gt;Bundle BitcoinJ/libdohj SPV name lookup client as an alternative to Namecoin Core.&lt;/li&gt;
      &lt;li&gt;TLS: Support Google Chrome Canary.  (Bug reported by samurai321.)&lt;/li&gt;
      &lt;li&gt;TLS: Fix bug in Chromium, Google Chrome, and Google Chrome Canary profile detection.  (Bug reported by samurai321.)&lt;/li&gt;
      &lt;li&gt;User is now prompted to uninstall before reinstalling.&lt;/li&gt;
      &lt;li&gt;Add additional debug output.  (Bug reported by samurai321.)&lt;/li&gt;
      &lt;li&gt;Detect when Namecoin Core or Dnssec-Trigger failed to install.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;All OS’s:
    &lt;ul&gt;
      &lt;li&gt;Various code cleanups.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Sep 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/09/26/ncdns-v0.0.5-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/09/26/ncdns-v0.0.5-released.html</guid>
        
        <category>Releases</category>
        
        <category>ncdns Releases</category>
        
        
      </item>
    
      <item>
        <title>Namecoin TLS for Firefox: Phase 1 (Overrides in C++)</title>
        <description>&lt;p&gt;Making TLS work for Namecoin websites in Firefox has been an interesting challenge.  On the positive side, Mozilla has historically exposed a number of API’s that would be useful for this purpose, and we’ve actually produced a couple of Firefox extensions that used them: the well-known Convergence for Namecoin codebase (based on Convergence by Moxie Marlinspike and customized for Namecoin by me), and the much-lesser-known nczilla (written by Hugo Landau and me, with some code borrowed from Selenium).  This was a pretty big advantage over Chromium, whose developers have consistently refused to support our use cases (which forced us to use the dehydrated certificate witchcraft).  On the negative side, Mozilla has a habit of removing useful API’s approximately as fast as we notice new ones.  (Convergence’s required API’s were removed by Mozilla about a year or two after we started using Convergence, and nczilla’s required API’s were removed before nczilla even had a proper release, which is why nearly no one has heard of nczilla.)  On the positive side, Mozilla has expressed an apparent willingness to entertain the idea of merging officially supported API’s for our use case.  So, I’ve been hacking around with a fork of Firefox, hoping to come up with something that Mozilla could merge in the future.  Phase 1 of that effort is now complete.&lt;/p&gt;

&lt;p&gt;In particular, I’ve created a C++ XPCOM component (compiled into my fork of Firefox) that hooks the certificate verification functions, and can produce both positive and negative overrides (meaning, respectively, that it can make invalid certs appear valid, and make valid certs appear invalid).  This XPCOM component has access to most of the data that we would want: it has access to the certificate, the hostname, and quite a lot of other data that Firefox stores in objects that the XPCOM component has access to.  Unfortunately, it doesn’t yet have access to the full certificate chain (I’m still investigating how to do that), and it also doesn’t yet have access to the proxy settings (I do see how to do that, it’s just not coded yet).  The full certificate chain would be useful if you want to run your own CA; the proxy settings would be useful for Tor stream isolation with headers-only Namecoin SPV clients.&lt;/p&gt;

&lt;p&gt;Performance is likely to be impacted, since this code is not even close to optimized (nor is performance even measured).  I’ll be investigating performance later.  Short-term, my next step will be to delegate the override decisions to JavaScript code.  (This looks straightforward, but as we all know, our friend Murphy might strike at any time.)  After that I’ll be looking at making that JavaScript code delegate decisions to WebExtensions.  The intention here is to support use cases besides Namecoin’s.  The WebExtensions API that this would expose would presumably be useful for DNSSEC/DANE verification, perspective verification, and maybe other interesting experiments that I haven’t thought of.&lt;/p&gt;

&lt;p&gt;Major thanks to David Keeler from Mozilla for answering some questions in IRC that I had about how the Firefox certificate verification code is structured.&lt;/p&gt;

&lt;p&gt;Hopefully I’ll have more news on this subject in the next couple weeks.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Sep 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/09/24/firefox-tls-cpp.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/09/24/firefox-tls-cpp.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Refactoring the Raw Transaction API</title>
        <description>&lt;p&gt;Several improvements are desirable for how Namecoin Core creates name transactions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Register names without having to unlock the wallet twice, 12 blocks apart.&lt;/li&gt;
  &lt;li&gt;Coin Control (a method of improving anonymity).&lt;/li&gt;
  &lt;li&gt;Specifying a fee based on when you need the transaction to be confirmed.&lt;/li&gt;
  &lt;li&gt;Pure name transactions (a method of improving scalability of Namecoin by decreasing transaction size).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these improvements, though they seem quite different in nature, have one important thing in common: they need to use the raw transaction API in ways that Namecoin Core doesn’t make easy.&lt;/p&gt;

&lt;h2 id=&quot;whats-the-raw-transaction-api&quot;&gt;What’s the raw transaction API?&lt;/h2&gt;

&lt;p&gt;Simply put, the raw transaction API is a Bitcoin Core feature that allows the user to create custom transactions at a much lower level than what a typical user would want.  The raw transaction API gives you a lot of power and flexibility, but it’s also more cumbersome and, if used incorrectly, you can accidentally lose lots of money.&lt;/p&gt;

&lt;h2 id=&quot;why-do-those-features-need-the-raw-transaction-api&quot;&gt;Why do those features need the raw transaction API?&lt;/h2&gt;

&lt;p&gt;The raw transaction API is useful for a few reasons.  First, it lets you create and sign transactions independently from broadcasting them.  That means you can create and sign a &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transaction before its preceding &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; transaction has been broadcast.  Second, it gives you direct control over the inputs, outputs, and fees for the transaction, whereas the standard name commands instead pick defaults for you that you might not like and can’t change.&lt;/p&gt;

&lt;h2 id=&quot;whats-wrong-with-namecoin-cores-raw-transaction-api&quot;&gt;What’s wrong with Namecoin Core’s raw transaction API?&lt;/h2&gt;

&lt;p&gt;It’s not raw enough!  First off, the only name transactions it can create are &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt;; it can’t create &lt;code class=&quot;highlighter-rouge&quot;&gt;name_new&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;name_firstupdate&lt;/code&gt; transactions.  That rules out handling name registrations, and consequently means that anonymously registering names or controlling the fee for name registrations is a no-go.  Secondly, it can’t create &lt;code class=&quot;highlighter-rouge&quot;&gt;name_update&lt;/code&gt; outputs with a higher monetary value than the default 0.01 NMC.  That rules out pure name transactions.&lt;/p&gt;

&lt;h2 id=&quot;how-are-we-fixing-this&quot;&gt;How are we fixing this?&lt;/h2&gt;

&lt;p&gt;We’re making an API change.  Instead of trying to stuff name operation data into &lt;code class=&quot;highlighter-rouge&quot;&gt;createrawtransaction&lt;/code&gt;, where it doesn’t belong and where it’s extremely difficult to provide the needed flexibility, we’re removing name support from &lt;code class=&quot;highlighter-rouge&quot;&gt;createrawtransaction&lt;/code&gt; and moving it to a new RPC call, &lt;code class=&quot;highlighter-rouge&quot;&gt;namerawtransaction&lt;/code&gt;.  The new workflow replaces the previous &lt;code class=&quot;highlighter-rouge&quot;&gt;createrawtransaction&lt;/code&gt; with two steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Use &lt;code class=&quot;highlighter-rouge&quot;&gt;createrawtransaction&lt;/code&gt; just like you would with Bitcoin, and specify a currency output of 0.01 NMC for where you want the name output to be.&lt;/li&gt;
  &lt;li&gt;Use &lt;code class=&quot;highlighter-rouge&quot;&gt;namerawtransaction&lt;/code&gt; to prepend a name operation to the scriptPubKey of the aforementioned currency output.  This has the effect of converting that currency output into a name output.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;what-will-be-the-impact&quot;&gt;What will be the impact?&lt;/h2&gt;

&lt;p&gt;Users of the raw transaction API will need to update their code.  If you’re using the raw transaction API to create currency transactions, then this will actually allow you to delete your Namecoin-specific customizations, since it will be just like Bitcoin again.  If you’re using the raw transaction API to create name transactions (this includes people who are doing atomic name trading), you’ll need to refactor your &lt;code class=&quot;highlighter-rouge&quot;&gt;createrawtransaction&lt;/code&gt;-using code so that it also calls &lt;code class=&quot;highlighter-rouge&quot;&gt;namerawtransaction&lt;/code&gt;.  If you’re a hacker who enjoys experimenting, this new workflow will probably be much more to your liking, as it will allow you to do stuff that you couldn’t easily do before.  And if you’re just an average user of Namecoin-Qt, you’ll probably like the new features that this enables, such as easier registration of names, better privacy, and lower fees.&lt;/p&gt;

&lt;h2 id=&quot;whos-involved-in-this-work&quot;&gt;Who’s involved in this work?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Jeremy Rand wrote a rough spec for the new API.&lt;/li&gt;
  &lt;li&gt;Daniel Kraft is implementing the changes to the API.&lt;/li&gt;
  &lt;li&gt;Jeremy Rand plans to utilize the new API in proof-of-concept scripts for several use cases (including the above 4 use cases).&lt;/li&gt;
  &lt;li&gt;Brandon Roberts plans to convert Jeremy’s proof-of-concept scripts into GUI features in Namecoin-Qt.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This work was funded in part by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;

&lt;h2 id=&quot;what-might-come-later&quot;&gt;What might come later?&lt;/h2&gt;

&lt;p&gt;Maybe Namecoin-Qt support for atomic name trading?  :)&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Sep 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/09/13/raw-tx-api-refactoring.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/09/13/raw-tx-api-refactoring.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>BitcoinJ support merged into ncdns-nsis</title>
        <description>&lt;p&gt;The ncdns-nsis project, which provides a zero-configuration Windows installer
for Namecoin domain name resolution functionality, has merged SPV support,
implemented via BitcoinJ. This enables Windows machines to resolve &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt;
domain names without having to download the full Namecoin chain.&lt;/p&gt;

&lt;p&gt;Merging this functionality means that Namecoin domain names can be resolved on
Windows client machines with only a minimal chain synchronization and storage
burden, in exchange for a limited reduction in the security level provided.&lt;/p&gt;

&lt;p&gt;Installer binaries will be published in due course as remaining ncdns-nsis
issues are concluded.&lt;/p&gt;

&lt;p&gt;To use the BitcoinJ client, run the ncdns-nsis installer and select the SPV
option when asked whether to install a Namecoin node. Run BitcoinJ after
installation and wait for synchronization to complete; &lt;code class=&quot;highlighter-rouge&quot;&gt;.bit&lt;/code&gt; name resolution
is then available.&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Sep 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/09/03/bitcoinj-ncdns-nsis.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/09/03/bitcoinj-ncdns-nsis.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>Video, Slides, and Paper from Namecoin at GCER 2017</title>
        <description>&lt;p&gt;As was &lt;a href=&quot;/2017/07/06/gcer-2017.html&quot;&gt;announced&lt;/a&gt;, I represented Namecoin at the 2017 Global Conference on Educational Robotics.  Although GCER doesn’t produce official recordings of their talks, I was able to obtain an amateur recording of my talk from an audience member.  I’ve also posted my slides, as well as my paper from the conference proceedings.&lt;/p&gt;

&lt;p&gt;It should be noted that, as this is an amateur recording, the audio quality is not spectacular.  It should also be noted that the audience is rather different from the audiences for whom I usually give Namecoin talks; as a result, the focus of the content is also rather different from my usual Namecoin talks.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.namecoin.org/files/videos/gcer-2017/Namecoin-GCER-2017-1080p.webm&quot;&gt;The WebM amateur video recording of my talk is here (hosted by Namecoin.org).&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/resources/presentations/GCER_2017/Namecoin_GCER_2017_Slides.pdf&quot;&gt;My slides are available here.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/resources/presentations/GCER_2017/Namecoin_GCER_2017_Paper.pdf&quot;&gt;My paper is available here.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge thanks to the staff and volunteers from KISS Institute for Practical Robotics, who organized GCER.  Especially big thanks to Roger Clement and Steve Goodgame for giving me excellent feedback on the general outline of my paper and talk.  This was an excellent event, and I look forward to the next time I’m able to attend.&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/08/31/gcer-2017-video.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/08/31/gcer-2017-video.html</guid>
        
        <category>News</category>
        
        
      </item>
    
      <item>
        <title>ncdns v0.0.4 Released</title>
        <description>&lt;p&gt;We’ve released ncdns v0.0.4.  This release incorporates a bugfix in the madns dependency, which fixes a DNSSEC signing bug.  The ncdns Windows installer in this release also updated the Dnssec-Trigger dependency.&lt;/p&gt;

&lt;p&gt;As usual, you can download it at the &lt;a href=&quot;/download/betas/&quot;&gt;Beta Downloads page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This work was funded by NLnet Foundation’s Internet Hardening Fund.&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Aug 2017 00:00:00 +0000</pubDate>
        <link>https://namecoin.org//2017/08/24/ncdns-v0.0.4-released.html</link>
        <guid isPermaLink="true">https://namecoin.org//2017/08/24/ncdns-v0.0.4-released.html</guid>
        
        <category>Releases</category>
        
        <category>ncdns Releases</category>
        
        
      </item>
    
  </channel>
</rss>
